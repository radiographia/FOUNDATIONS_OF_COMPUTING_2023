<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Requirements for Multimedia Database Systems</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part418.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part420.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark417" name="bookmark2015">Requirements for Multimedia Database Systems</a><a name="bookmark2086">&zwnj;</a></p><p class="s46" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part507.htm#bookmark2382" class="s23" name="bookmark2087">To deal with multimedia data, multimedia database systems must meet certain special requirements. These requirements are both from the perspective of special hardware and software features of computer systems as well as special database features for handling multimedia data. As </a><a href="part507.htm#bookmark2382" class="s3">Chapter </a>14<span class="s10"> </span><span class="p">deals with hardware and software requirements for handling multimedia data, here we will deal with only the database features for handling multimedia data.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Support for Multimedia Data Storage and Retrieval</h4><p class="s46" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part507.htm#bookmark2382" class="s23">By their very nature, multimedia data are huge in volume. A multimedia database should be capable of storing and managing several gigabytes of data for small multimedia data objects such as images, and several hundred terabytes or more of data, if the database must hold large amount of video or animation data. To meet the requirement of huge data volumes, multimedia database systems often use a hierarchy of storage devices. The storage hierarchy typically consists of primary storage (such as random access memories), secondary storage (such as magnetic disks), and tertiary storage (such as CD jukeboxes, or magnetic tape libraries). In a hierarchical storage system like this, performance of data retrieval depends on the efficiency of migration mechanism, which decides optimal level of each multimedia data item in the storage hierarchy. Systems often use data compression and decompression techniques (described in </a><a href="part507.htm#bookmark2382" class="s3">Chapter </a>14<span class="p">) to deal with the requirement of huge data volumes.</span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Hence, a DBMS for multimedia databases typically requires mechanisms for handling huge data storage (possibly comprising of multi-level hierarchy), migrating data automatically from one level to another in the storage hierarchy for efficient data retrieval, compressing and decompressing data at the time of storage and retrieval respectively, and transferring and distributing huge volumes of data across the network.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Support for Multimedia Data Types</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A DBMS for multimedia databases must provide type support for common multimedia data types. It is not sufficient for a multimedia database system to serve only as a repository of multimedia data, but the database system must also be intelligent enough to understand the data it manages. Hence, it must have the capability to recognize and operate on several standard multimedia data formats, such as JPEG, GIF, and MPEG. Internally, a DBMS for multimedia databases may support a single (perhaps proprietary) data format for each data type. For example, it may internally treat all types of multimedia data as Blobs (binary large objects), as in simple data repositories that do not recognize or support multimedia data formats. In this case, the multimedia database system must have conversion routines to convert data from original format to internal format on import to the database, and from internal format to original format on export from the database.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Some multimedia data types such as video, audio, and animation sequences also have temporal (time-related) requirements, which have implications on their storage, manipulation, and presentation. Similarly, images, graphics, and video data have spatial (space-related) constraints in terms of their content. A multimedia database system designer must design it in such a manner</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">that the database understands and meets these additional requirements of these multimedia data types for handling them.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Support for Multimedia Data Relationships</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A multimedia database system supports multiple data types. For effective presentation of multimedia data to its users, the system often needs to integrate two or more data types to form a new composite multimedia data type. Often this requires establishment of spatial (space-related), temporal (time-related), and/or synchronization relationships among various data items of different  types.  <i>Spatial  relationships  </i>organize  the  data&#39;s  visual  layout.  For  example, superimposition of a text object on a specific part of an image/video object when the system displays them together. <i>Temporal relationships </i>define temporal layout, ensuring timely presentation of the right data. A simple example might be, “Play video<i>v1 </i>and audio <i>a1</i>, and thereafter, play music<i>m1 </i>until slide show <i>s1 </i>is done”. <i>Synchronization relationships </i>define synchronization of two or more objects when the system presents them together to the users(s). For example, maintaining lip synchronization between a video and a sound track while showing a movie. To take care of such multimedia data composition and presentation requirements, a multimedia database system should provide facilities to define and support various types of relationships between multimedia data objects.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark2088">Support for Multimedia Data Modeling</a></h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A multimedia database model must have features to capture static and dynamic properties of a multimedia database contents (multimedia data). Static properties include data items that make up the multimedia data, relationships between the data items, data item attributes, and so on. Examples of dynamic properties include interaction between data items, operations on data items, user interaction, and so on.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Object-oriented database model is the most suitable model for multimedia databases. Most multimedia database systems implement multimedia data types as classes, having attributes and methods to support each data type. They may be part of a large class hierarchy or framework. A framework goes beyond a simple type definition to give more complete support for the data types, including several methods and additional supporting classes (to import, view, and export). While type frameworks focus on type-specific support, a database model for multimedia databases must also have features to express various types of relationships between multimedia data types for composition and presentation. Hence, a database model for multimedia databases goes much beyond an ordinary object-oriented database model, which designers use for modeling traditional databases.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Support for Multimedia Data Manipulation</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A DBMS needs to provide support for easy manipulation of data in a database. Implementing features for manipulation of simple data types is simple. However, multimedia databases require multimedia data manipulation languages (DMLs) or constructs with features to support not only simple cut or crop operations on multimedia data, but also to ensure that these operations adhere to spatial, temporal, and synchronization constraints. For example, for temporal constraints, these operations must provide predictable and worst-case information about the operation overhead.</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">This lets the system determine if it can meet guarantees of quality of service (QoS) when it inserts the operation within the data stream between the source (database server) and the sink (the viewer).</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Another concept related to data manipulation, which DBMSs for multimedia databases use, is that of <i>derived data</i>. A database needs to store a modified data in the database for future reference. It may either replace the old version or retain it as another version of the data. If users constantly create new versions of data, the database size will grow rapidly. To reduce the need to store new versions of data, a DBMS for multimedia databases stores the operations to generate the new data (called derived data), rather than storing the new data itself.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Support for Multimedia Data Query</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A user initiates a query to extract some information from a database. A query contains predicates, and in response to the query, the DBMS returns to the user those data from the database, which satisfy (match) the predicates. It is easy to formulate predicates and look for its matching data in conventional databases. For example, “Find all employees for whom CITY = “PUNE” and AGE &gt; 40”. However, this is not easy while dealing with multimedia data. Multimedia database systems use the following three methods for querying multimedia data:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Manual keyword indexing. </b>In this method, descriptive keywords are manually associated with each multimedia data in a multimedia database. For example, a set of keywords for describing an image data of a face could be “long face, sharp pointed nose, broad moustache, no beard, fair complexion, mole on right side of chin”. These keywords are <i>metadata</i>, since they are data about the multimedia data. For querying, a user specifies some keywords and the DBMS looks for images with matching keywords (it does not look at the images at all). It returns all images with matching keywords as the result of the query./p&gt;</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">This method has the following limitations:</p><p style="padding-top: 8pt;padding-left: 54pt;text-indent: 0pt;text-align: justify;">a. Keyword classification is subjective, since a human being does the classification.</p><p style="padding-top: 4pt;padding-left: 69pt;text-indent: -15pt;text-align: justify;">b. Exceptions will always exist no matter what keyword classification scheme the system uses. Hence, the system classifies some data incorrectly.</p><p style="padding-top: 4pt;padding-left: 69pt;text-indent: -15pt;text-align: justify;"><a name="bookmark2089">c. Usually, key wording is limited to a well-defined abstraction of data. For example, for every image of a face, a database designer classifies a specific set of features. However, if the designer alters the abstraction of image of a face later, then the system must review all data, adding new keywords as required. This could be a formidable task even for small databases.</a></p><p style="padding-top: 8pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. <b>Content-Based Retrieval/Querying (CBR/CBQ). </b>In this method, queries are based on the content of multimedia data. When a data is entered to a database, the system subjects it to data analysis to derive certain attributes of the data (called derived data). Derived data could include attributes such as lines, shapes, colors, and textures from which the system can determine objects. Queries against this data then take place on the derived data. For example, “Find all graphic objects having red triangles and green circles”. Similarly, “Find all video clips having a flying aeroplane”.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">To distinguish CBR on temporal data such as video and audio, from that on images and</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">graphics, CBR on images and graphics are called <i>static CBR </i>(or SCBR), and CBR on video, animation, and audio are called <i>dynamic CBR </i>(or DCBR).</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">With both types of CBR, specifying precise queries (exact matching) is generally not practical. Therefore, multimedia database query languages must have features to support fuzzy predicates such as “Looks like this” to find approximate matches. Furthermore, since queries might not yield exact matches, multimedia database query languages must have facilities for ranking the query results based on how closely they match the given query.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. <b>Query By Example (QBE). </b>QBE is a special user interface to support CBR in multimedia database systems. These interfaces allow a user to specify the attributes of object(s) of interest by providing examples to match such as, a drawing, photograph, action, or sound. For example, the user can draw an example of the type of image he/she is interested in by using shape, color, or texture (such as a face sketch). The query manager then uses that example to extract similar images (photographs of people matching the sketch) from the database.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Support for Multimedia User Interface</h4><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The diverse nature of multimedia data requires an equally diverse user interface for interacting with a multimedia database. Since multimedia database systems require spatial and temporal rendering of multimedia data, user interface of multimedia databases must include features to control and devices to render the presentation. This may include simple VCR-type control panels enabling a user to play, fast-forward, pause, or rewind a presentation, as well as more advanced controls including interactive data filtering, querying, and visual perspective controls. In addition, the user interface should also have features to allow a user to control the quality of service (QoS) parameters to adjust for resource limitations, cost of delivery, and personal visual and aural preferences.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part418.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part420.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
