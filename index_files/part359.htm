<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Multiprogramming Memory Models</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part358.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part360.htm">Далее &gt;</a></p><p style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark357" name="bookmark1818">Multiprogramming Memory Models</a><a name="bookmark1908">&zwnj;</a><a name="bookmark1909">&zwnj;</a></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">In a multiprogramming system, multiple user processes can reside simultaneously in main memory. The two memory management schemes, which operating systems use to facilitate this, are multiprogramming with fixed number of memory partitions and multiprogramming with variable number of memory partitions. They are described here.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Multiprogramming with Fixed Number of Memory Partitions</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part359.htm#bookmark1910" class="s23">In this scheme, the operating system divides the user area of memory into a number of fixed- sized partitions. These partitions may be of equal or different sizes, but the size of each partition is fixed. </a><a href="part359.htm#bookmark1910" class="s3">Figure </a><span class="s46">10.16</span> shows a multiprogramming memory model with <i>n </i>equal-sized partitions. Each partition may contain exactly one process. Hence, the number of partitions bounds the degree of multiprogramming. That is, in a system with <i>n </i>memory partitions, the system can load maximum <i>n </i>processes at a time. The operating system queues all new jobs in an input queue. When a partition is free, it loads the next job from the input queue into that partition. When a process terminates, the partition it occupies becomes free for use by another process. In a system that uses partitions of different sizes, when a partition becomes free, the operating system loads the first process that fits in it from the input queue.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 151pt;text-indent: 0pt;text-align: left;"><span><img width="235" height="162" alt="image" src="Image_623.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 229pt;text-indent: -219pt;text-align: left;"><a name="bookmark1910">Figure 10.16. </a><span class="s21">Multiprogramming memory model with fixed number of memory partitions (all partitions of equal size).</span></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">IBM OS/360 mainframe systems used this scheme of memory management for several years. It was called <i>MFT </i>(<i>Multiprogramming with a Fixed number of Tasks</i>). It is no longer in use.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Multiprogramming with Variable Number of Memory Partitions</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">In the earlier scheme, since all partitions are of fixed size, any space in a partition that is in excess of actual memory requirement of the process loaded into it remains unused. On an average, 50% of memory may remain unused due to this, resulting in under utilization of memory resource. The scheme with variable number of memory partitions overcomes this problem. In this scheme, the number, sizes, and locations of partitions vary dynamically as processes enter and exit the system.</p><p class="s46" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part360.htm#bookmark1913" class="s3">Figure </a>10.17<span class="s10"> </span><span class="p">illustrates this memory management scheme with an example. Initially, all memory in user area is available for user processes. When a process enters the system, the operating system allocates to it only as much memory as it needs, keeping the rest available for future requests. As processes enter and exit, the operating system allocates and de-allocates memory partitions to them, each partition being equal to the size of memory required by the</span></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">corresponding process. Since memory requirement of different processes is generally different, as processes enter and exit the system, the system&#39;s memory is partitioned into various sizes of free memory blocks. Operating system maintains a table to keep track of free memory blocks. When a new process arrives, the operating system searches for a free block that is large enough for this process. If the free block is too large, the operating system splits it into two parts. One part is large enough for the process, while the other part contains remaining memory from that block. The operating system allocates the former part to the process and enters the latter part as a smaller free block in the free blocks table. When a process terminates, it releases the partition allocated to it. The operating system enters the released partition as a free memory block in the free blocks table. However, if the released partition is adjacent to any free block/blocks, the operating system merges it with the adjacent free block/blocks to create a larger free block, and updates the associated entries in the free blocks table.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part358.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part360.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
