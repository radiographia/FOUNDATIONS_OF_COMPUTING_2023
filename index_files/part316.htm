<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Compiler</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part315.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part317.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark314" name="bookmark1681">Compiler</a><a name="bookmark1733">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A <i>compiler </i>is a translator program (more sophisticated than an assembler) that translates a high- level language program into its equivalent machine language program. It is so called because it compiles a set of machine language instructions for every program instruction of a high-level language.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part316.htm#bookmark1734" class="s23">As </a><a href="part316.htm#bookmark1734" class="s3">Figure </a><span class="s46">9.7</span> shows, input to the compiler is a high-level language program (often referred to as <i>source program</i>), and its output is the equivalent machine language program (often referred to as <i>object program</i>). High-level language instructions are macro instructions. The compiler translates each high-level language instruction into a set of machine language instructions rather than a single machine language instruction. Hence, there is a one-to-many correspondence between the high-level language instructions of a source program and the machine language instructions of its equivalent object program. Note that during the process of translation of a source program into its equivalent object program by the compiler, the source program is not under execution. The compiler only converts it into a form that the computer can execute.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 70pt;text-indent: 0pt;text-align: left;"><span><img width="451" height="98" alt="image" src="Image_573.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1734">Figure 9.7. </a><span class="s21">Illustrating the translation process of a compiler.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part316.htm#bookmark1735" class="s23">A compiler can translate only those source programs that are written in the language, which the compiler can translate. For example, a FORTRAN compiler can translate only source programs written in FORTRAN. Therefore, a computer requires a separate compiler for each high-level language that it supports. For example, to be able to execute both FORTRAN and COBOL programs, a computer must have both FORTRAN and COBOL compilers. </a><a href="part316.htm#bookmark1735" class="s3">Figure </a>9.8<span class="s10"> </span><span class="p">illustrates this.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 103pt;text-indent: 0pt;text-align: left;"><span><img width="364" height="216" alt="image" src="Image_574.jpg"/></span></p><p class="s20" style="padding-top: 3pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1735">Figure 9.8. </a><span class="s21">Illustrating the requirement of a separate compiler for each high-level language supported by a computer.</span></p><p class="s46" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part316.htm#bookmark1736" class="s23">Also, note that an object program for one computer may not be the same as the object program for another computer. Hence, each computer must have its own “personal” compiler for a language, say L1. </a><a href="part316.htm#bookmark1736" class="s3">Figure </a>9.9<span class="s10"> </span><span class="p">illustrates how we can achieve machine-independence by using different compilers to translate the same high-level language program to machine language programs of different computers.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Compilers are large programs residing permanently on secondary storage. To translate a source program, a computer first loads the compiler and the source program from secondary storage into its main memory. The computer then executes the compiler (which is also a program) with the source program as its input data. It generates the equivalent object program as its output, which the computer saves in a file on secondary storage. To execute the program, the computer loads the object program into main memory from secondary storage and executes it. Note that, there is no need to repeat the compilation process every time we wish to execute the program. This is because the object program stored on secondary storage is already in machine language, which we can load into main memory from the secondary storage and execute it whenever required. Also, note that compilation is necessary whenever we modify the program. That is, to incorporate changes in the program, we must load the original source program into main memory from secondary storage, carry out necessary changes in the source program, recompile the modified source program, and create and store an updated object program for execution.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 48pt;text-indent: 0pt;text-align: left;"><span><img width="510" height="188" alt="image" src="Image_575.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1736">Figure 9.9. </a><span class="s21">Illustrating the machine independence characteristic of a high-level language.</span><a name="bookmark1737">&zwnj;</a></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Separate compilers are required for the same language on different computers.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">In addition to translating high-level language instructions into machine language instructions, compilers also detect and indicate certain types of errors in source programs. We refer to these errors as <i>syntax errors. </i>They are of the following types:</p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. Illegal characters</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. Illegal combination of characters</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3. Improper sequencing of instructions</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">4. Use of undefined variable names</p><p style="padding-top: 9pt;padding-left: 2pt;text-indent: 0pt;text-align: center;">If a compiler detects one or more errors in a source program, it will not compile it into an object program. In this case, the compiler generates a list of coded error messages indicating the type of</p><p class="s46" style="padding-top: 3pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part316.htm#bookmark1738" class="s23">errors committed. The programmer uses this error list to re-edit the source program for removing the errors, and creates a modified source program for recompilation (see </a><a href="part316.htm#bookmark1738" class="s3">Figure </a>9.10<span class="p">). As the figure shows, we have to repeat the process of editing the source program to make necessary corrections and recompiling the modified source program until the source program is free of all syntax errors. Also, notice from the figure that the compiler generates the object program only when the source program is free of all syntax errors.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">A compiler, however, cannot detect <i>logic errors</i>. It can only detect grammatical (syntax) errors in the source program. It cannot know ones intentions. For example, if one has wrongly entered 35 instead of 45 as the value for second division percentage to be compared with <i>Percentage, </i>or 999999 (only six 9s) instead of 9999999 (seven 9s) as the sentinel value for <i>Rollno</i>, the compiler cannot detect this.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 131pt;text-indent: 0pt;text-align: left;"><span><img width="290" height="320" alt="image" src="Image_576.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 52pt;text-indent: 0pt;text-align: left;"><a name="bookmark1738">Figure 9.10. </a><span class="s21">Illustrating recompilation of a source program, until it is free of syntax errors.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">A compiler successfully compiles programs containing such errors, and generates the object code for it without generating any error message. However, such programs, when executed, do not produce correct result or do not behave as expected. Hence, we can detect logic errors in a program only after we execute the program, and find that the result does not tally with the desired result, or the program does not behave as expected.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part315.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part317.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
