<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Software Design Approaches</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part224.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part226.htm">Далее &gt;</a></p><p style="padding-bottom: 3pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark223" name="bookmark1356">SOFTWARE DESIGN APPROACHES</a><a name="bookmark1428">&zwnj;</a></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="624" height="1" alt="image" src="Image_444.png"/></span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The three software design approaches used commonly are top-down, bottom-up, and out-of-the- middle. They are described here.</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Top-down approach. </b>The top-down approach starts with system architecture definition in which the designer defines the overall system architecture in terms of its major components. The architecture includes a set of relationships among components (for example, hierarchical structure, interfaces, communications, and process dependencies). In the next step, the designer defines the architecture of each major component in terms of its sub-components and a set of relationships among the sub-components. He/she then defines the architecture of each sub-component in terms of its sub-sub-components and a set of relationships among the sub-sub-components. This process of decomposing components and sub-components continues until the designer reduces all components and sub-components to base elements, further decomposition of which is not possible. All components, sub-components, sub-sub-components, and so on defined in the process along with their specifications and relationships among them form the complete system architecture. The components, sub-components, sub-sub-components, and so on are</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">implemented (coded in a programming language) and linked properly to build the system in the implementation phase.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;"><a href="part225.htm#bookmark1430" class="s3">Figure </a><span class="s46">7.4</span> illustrates this approach. It is also known as <i>decomposition approach </i>because it arrives at the complete system architecture by decomposing components and sub- components into additional sub-components, until the entire system specification is reduced to base elements.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">This approach was popular until the late 1980s. The other two approaches have now replaced it. However, designers still use this approach in those situations where gap analysis between the requirements of the target system and the available software components indicates low functional fit.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><a name="bookmark1429">2. </a><b>Bottom-up approach. </b>The bottom-up approach starts with base elements selection and specification in which the designer first does a survey of available software libraries and/or existing applications and selects those base elements that can serve as useful building blocks for the target software system. He/she also lists the current specifications of the selected base elements. In the next step, the designer lists modifications required (if any) in the base elements to change their current specifications to match the specifications/requirements of the target software system. For example, modifications may be required to make them suitable for the hardware, operating system, etc. of the target system. He/she then defines linkages among the base elements to create sub- components, which form sub-systems of the target system. In the next step, he/she defines linkages among the sub-systems to create larger sub-systems of the target system. The designer continues with this process of defining linkages among the sub-systems of the previous step to create larger sub-systems until he/she forms a complete top-level system. The selected base elements along with their current specifications and customization requirements (if any), and the linkages defined at various levels to create sub-components, larger sub-systems, and the complete top-level system together form the complete system architecture. The base elements are customized and linked properly (as defined in the system architecture) to build the system in the implementation phase.</p><p style="padding-left: 117pt;text-indent: 0pt;text-align: left;"><span><img width="371" height="410" alt="image" src="Image_445.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 142pt;text-indent: 0pt;text-align: left;"><a name="bookmark1430">Figure 7.4. </a><span class="s21">The top-down approach of software design.</span></p><p style="padding-top: 8pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;"><a href="part225.htm#bookmark1431" class="s3">Figure </a><span class="s46">7.5</span> illustrates this approach. It is also known as <i>synthesis approach </i>because it arrives at the complete system architecture by synthesizing base elements into sub- systems, and sub-systems into larger sub-systems, and so on until a complete top-level system is formed. Re-usability of code is one of the main benefits of this approach. Object-oriented paradigm, which promotes re-usability of code in the form of re-usable objects, popularized this approach.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">This approach is suitable for use in those situations where gap analysis between the requirements of the target system and the available software components indicates high functional fit.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. <b>Out-of-the-middle approach. </b>This approach combines both top-down and bottom-up approaches. It is the most popular approach for designing modern software systems because software industry has matured over the years and re-usable software components for almost all domains are available today. Hence, most modern software projects make use of a mix of existing software components and newly developed components to build the complete target software system.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">In this approach, the designer first uses the top-down approach to define a high-level architecture of the target system. He/she then uses the bottom-up approach to fill in the detailed architectural levels. Thereafter, he/she identifies additional components and their relationship with other components to fill the gaps remaining to complete the architecture. In the implementation phase, the team customizes (if required) the components that have been identified by the bottom-up approach and implements the new components. The</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">team then links all the components (as defined in the system architecture) to build the target system.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 114pt;text-indent: 0pt;text-align: left;"><span><img width="378" height="536" alt="image" src="Image_446.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 141pt;text-indent: 0pt;text-align: left;"><a name="bookmark1431">Figure 7.5. </a><span class="s21">The bottom-up approach of software design.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part224.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part226.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
