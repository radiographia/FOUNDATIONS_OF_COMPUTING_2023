<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Unicode</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part49.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part51.htm">Далее &gt;</a></p><p style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark48" name="bookmark707">Unicode</a><a name="bookmark758">&zwnj;</a><a name="bookmark759">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Need for Unicode</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">As computers became popular across the world, their usage could not be limited to English language users only. Hence, people started developing computer systems that could allow interaction and processing of data in local languages of users (e.g., Hindi, Japanese, Chinese, Korean, etc.) This required support of local language characters and other language-specific symbols on these computer systems. ASCII or EBCDIC did not have enough number of bits to</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">accommodate all the characters and language-specific symbols of a local language, in addition to English alphabet characters and special characters. Hence, different groups designed encoding systems to cater to this requirement of different local languages. In the process, hundreds of different encoding systems came into existence. Although, this looked fine initially, it later led to a chaotic state of affairs due to the following reasons:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. No single encoding system had enough bits and an adequate mechanism to support characters of all types of languages used in the world. Hence, supporting of characters from multiple languages on a single computer system became tedious since it required supporting of multiple encoding systems on the computer. With hundreds of different encoding systems in use across the world, it became impossible to support all of them on a single system.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. Different encoding systems developed independently conflicted with one another. That is, two encoding systems often used the same code for two different characters or used different codes for the same character. Due to this, whenever data transfer took place between computer systems or software using different encoding systems, the data was at the risk of corruption.</p><p class="s46" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="http://www.unicode.org/standard/WhatIsUnicode.html" class="s23" target="_blank">As a result, it became difficult to exchange text files internationally. The Unicode standard was designed to overcome these problems. It is a universal character-encoding standard used for representation  of  text  for  computer  processing.  The  official  Unicode  web  site (</a><a href="http://www.unicode.org/standard/WhatIsUnicode.html" class="s11" target="_blank">www.unicode.org/standard/WhatIsUnicode.html</a>)<span class="s10"> </span><span class="p">states that it is an encoding system that “provides a unique number for every character, no matter what the platform, no matter what the program, no matter what the language”.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Unicode Features</h4><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Today, Unicode is a universally accepted character-encoding standard because:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. It provides a consistent way of encoding multilingual plain text. This enables data transfer through different systems without the risk of corruption.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. It defines codes for characters used in all major languages of the world used for written communication. This enables a single software product to target multiple platforms, languages, and countries without re-engineering.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. It also defines codes for special characters (such as various types of punctuation marks), mathematical symbols, technical symbols, and diacritics. <i>Diacritics </i>are modifying character marks such as tilde (~), that are used in conjunction with base characters to represent accented letters (indicating different sound - for example, ñ).</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">4. It has the capacity to encode as many as a million characters. This is large enough for encoding all known characters including all historic scripts of the world as well as common notational systems.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">5. It assigns each character a unique numeric value and name, keeping character coding simple and efficient.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">6. It reserves a part of the code space for private use to enable users to assign codes for their own characters and symbols.</p><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;"><a name="bookmark760">7. It affords simplicity and consistency of ASCII. Unicode characters that correspond to the familiar ASCII character set have the same byte values as that of ASCII. This enables use of Unicode in a convenient and backward compatible manner in environments designed around ASCII, like UNIX. Hence, Unicode is usable with existing software without extensive software rewrites.</a></p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">8. It specifies an algorithm for presentation of text with bi-directional behavior. For example, it can deal with a text containing a mixture of English (which uses left-to-right scripts) and Arabic (which uses right-to-left scripts). For this, it includes special characters to specify changes in direction when scripts of different directions are mixed. For all scripts, Unicode stores a text in logical order within the memory representation corresponding to the order of typing on the keyboard.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Unicode has a lot of room to accommodate new characters. Moreover, its growth process is strictly additive in the sense that new characters can be added easily, but existing characters cannot be removed. This feature ensures that interpretation of data once encoded in Unicode standard will remain in the same way by all future implementations that conform to original or later versions of the Unicode standard.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Unicode Encoding Forms</h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">In addition to defining the identity of each character and its numeric value (also known as <i>code point</i>), character-encoding standards also define internal representations (also known as <i>encoding forms</i>) of each character (how its value is represented in bits). Unicode standard defines the following three encoding forms for each character:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. <b>UTF-8 (Unicode Transformation Format-8). </b>This is a byte-oriented format having all Unicode characters represented as a variable length encoding of one, two, three or four bytes (remember, 1 byte = 8 bits). This form is useful for dealing with environments designed around ASCII because the Unicode characters that correspond to the familiar ASCII character set have the same byte values as that of ASCII. This form is also popular for HTML and similar protocols.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. <b>UTF-16 (Unicode Transformation Format-16). </b>This is a word-oriented format having all Unicode characters represented as a variable length encoding of one or two words (remember, 1 word = 16 bits). This form is useful for environments that need to balance efficient access to characters with economical use of storage. This is because all the heavily used characters can be represented by and accessible via a single word (16-bit code unit), while all other characters are represented by and accessible via a pair of words. Hence, this encoding form is compact and efficient, yet provides support for larger number of characters.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">3. <b>UTF-32 (Unicode Transformation Format-32). </b>This is a double-word oriented format having all Unicode characters represented as a fixed length encoding of two words (remember, 1 word = 16 bits). That is, a double word (32-bit code unit) encodes each character. This form is useful for environments where memory space is not a concern, but users desire fixed width (single code unit) access to characters.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Notice that at most 4 bytes (32 bits) are required for each character in all three forms of</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">encoding. With the three forms of encoding supported, transmission of the same data in a byte, word, or double-word format (i.e., in 8, 16, or 32-bits per code unit) is possible, depending on its usage environment. Unicode standard also provides the facility to transform Unicode encoded data from one form to another without loss of data.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Handling of Text Elements by Unicode</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A text consists of words and sentences, which are created using text elements. The concept of text element may be different for different languages used in the world. For example, in English, we use <i>letters </i>(A, B, C…a, b, c…) as text elements; and in Chinese language, we use <i>ideographs </i>(which represents full word or concepts) as text elements. Moreover, the definition of text elements also depends on the process handling the text. For example, when sorting is done for historic Spanish language, “II” is treated as a single text element, whereas, it is treated as two separate text elements - “I” and “I”, when Spanish words are typed.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark761">To avoid deciding what is (and what is not) a text element in different processes used for handling text, the Unicode standard defines </a><i>code elements </i>(also known as <i>characters) </i>instead of text elements. For most languages, code elements correspond to the commonly used text elements. Moreover, the Unicode standard defines each “I” of the Spanish “II” as a separate code element and leaves the task of combining two “I” together for alphabetic sorting to the text processing software.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Handling of Various Types of Characters by Unicode</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Since Unicode is an encoding system for supporting all types of languages used in the world, it has to deal with many different types of characters and character sequences used in different languages. Some of the commonly encountered types of characters and character sequences along with the manner in which Unicode handles them are given here.</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. <b>Simple characters. </b>Unicode treats a simple character (like the letter “A”) as a code element. It assigns a single member to each of these characters. Each of these numbers is called a <b>code point</b>. When referred to in text, a code point is listed in hexadecimal form following the prefix “U”. For example, the code point for character “A” is U+0041, where 0041 is the hexadecimal number (equal to the decimal number 65).</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. Unicode also assigns a unique name to each character, which it uses to identify it uniquely. For example, it assigns the unique name “LATIN CAPITAL LETTER A” to “A”. Other  examples  of  unique  names  assigned  to  characters  by  Unicode  are “BENGASLI DIGIT 5” and “GURUMUKHI LETTER CHA”.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">3. <b>Composite characters. </b>Composite characters (like the characters “ü” and “ n ”) are often used in Latin. They are also known as <i>precomposed characters</i>. The Unicode standard encodes composite characters as single character (encoded as a single code point) and defines the decompositions for all composite characters as the base character (encoded as a code point) followed by the non-spacing character (encoded as another code point). For example, the composite character “ü” is encoded as the single code point U+00FC, and can be decomposed as the base character “u” (having the code point U+0075) followed by the non-spacing character “..” (having the code point U+0308).</p><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">4. Unicode defines decomposition of composite characters for consistency and analysis. For example, while alphabetical sorting of a list of names, the character “ü “ may be decomposed into a “ü” followed by the non-spacing character “..”. Once the character has been decomposed, it may be easier for the sorting routine to work with the character because it can be processed as a “ü” with modifications. This allows easier alphabetical sorting for languages where character modifiers do not affect alphabetical order.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">5. <b>Duplicate characters in multiple languages. </b>Different languages, which have a common origin, often use many common characters. For example, Chinese, Japanese, and Korean languages share many thousands of identical characters because their ideograph sets evolved from the same source. To avoid duplicate encoding of such characters, the Unicode Standard unifies characters within scripts across languages and assigns a single code to each such character. That is, it assigns a single code point to characters, which are equivalent in form across multiple languages.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">6. <b>Glyphs. </b>A glyph is a visual representation of a character, when the character is displayed on screen or printed on paper. We often come across the same character displayed or printed in different sizes, shapes and styles in printed documents or displayed text. For example, capital “A” appears as “A” in Helvetica font and as “A” in Courier font.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">The Unicode standard does not define glyphs (the size, shape, or style of displayed or printed forms of characters). It only defines how characters are interpreted, not how glyphs are rendered. It is the responsibility of the software or hardware-rendering engine of a computer to deal with the appearance of characters, when the computer displays or prints them.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark762">Partitions of Unicode Codespace</a></h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">The Unicode standard (Version 4.0) defines codes (code points) for about 96,500 characters from the world&#39;s alphabets, ideograph sets, and symbol collections. The entire range of already defined code points along with the space reserved for code points for private use as well as those for future expansions form the Unicode <i>codespace</i>.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">In Unicode codespace, characters are grouped together by scripts in code blocks. A <i>script </i>is a set of related characters. For example, all the characters used in Devnagari form the Devnagari script. Similarly, there are Arabic, Greek, Hebrew, and other scripts. If a script defines an order of the characters (for example, A, B, C, ... is the alphabetic ordering of the characters A…Z), the Unicode Standard maintains the same order whenever possible in its code space. That is, the code points assigned to the set of characters in the script are in the same order (for example, U+0041 for A, U+0042 for B, U+0043 for C, and so on). All the code points assigned to the characters of a script form a <i>code block. </i>Since the number of characters in different scripts varies greatly, the code blocks also vary greatly is size. For example, the code block for the Cyrillic script has 256 code points, while the code block for the combined ideographs of Chinese, Japanese and Korean languages (to avoid duplication) contains thousands of code points.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">In Unicode codespace, coding starts at U+0000 with the standard ASCII characters, and continues with Greek, Cyrillic, Hebrew, Arabic, Indic, and other scripts. Code point for symbols and punctuations follow these. Hiragana, Katakana, Bopomofo, Hangul and the unified ideographs of Chinese, Japanese, and Korean languages form the subsequent code blocks of codespace.</p><p class="s16" style="padding-top: 3pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Basic Multilingual Plan <span class="p">(BMP in short) is an area of codespace that contains code points for the commonly used characters (about 64K code points), and space for about 6,300 unused code points for future expansion. Towards the end of the BMP, there is space for 6,400 code points, reserved for private use. A range of </span>compatibility characters <span class="p">follows this. These encoded character variants enable transcoding to earlier standards and old implementations that made use of them.</span></p><p class="s16" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Private use area <span class="p">of the codespace is for characters specific to a program or a group of users. Vendors or end users can assign these internally for their own characters and symbols, or use them with specialized fonts. For example, a group of choreographers may design a set of characters for dance notation and encode the characters using code points in the private use area. Similarly, a set of page-layout programs may use the same code points as control codes to position text on the page. These code points have no universal meaning, as the Unicode standard does not assign any meaning to them. There are 6,400 code points, on the BMP and another 131,068 supplementary private use code points, should 6,400 be insufficient for some applications.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part49.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part51.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
