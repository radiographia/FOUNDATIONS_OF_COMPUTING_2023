<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Graph</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part300.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part302.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark299" name="bookmark1530">Graph</a><a name="bookmark1645">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">A <i>graph </i>is a collection of <i>nodes </i>(also called <i>vertices</i>) and <i>edges </i>(also called <i>lines</i>). Each edge (<i>i, j</i>) joins two nodes <i>i </i>and <i>j</i>. We frequently use the following terminologies with graphs:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><a name="bookmark1646">1. </a><b>Directed edge. </b>An edge with an orientation is a directed edge. Hence, a directed edge (<i>i, j</i>) is different from the directed edge (<i>j, i</i>), the former being oriented from node <i>i </i>to node <i>j </i>and the latter from node <i>j </i>to node <i>i</i><a href="part301.htm#bookmark1647" class="s23">. The graph of </a><span class="s46">Figure 8.46</span>(b) has directed edges.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. <b>Undirected edge. </b>An edge with no orientation is an undirected edge. Hence, undirected edges (<i>i, j</i>) and ( <i>j, i</i><a href="part301.htm#bookmark1647" class="s23">) are the same. The graph of </a><span class="s46">Figure 8.46</span>(a) has undirected edges.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">3. <b>Directed graph. </b>If all edges of a graph are directed edges, then the graph is called a directed graph (also called <i>digraph</i><a href="part301.htm#bookmark1647" class="s23">). The graph of </a><span class="s46">Figure 8.46</span>(b) is a digraph.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">4. <b>Undirected graph. </b>If all edges of a graph are undirected edges, then the graph is called an undirected graph (also called <i>graph</i><a href="part301.htm#bookmark1647" class="s23">). The graph of </a><span class="s46">Figure 8.46</span>(a) is an undirected graph.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">5. <b>Weighted graph/digraph. </b>When we assign weights to the edges of a graph/digraph, we call the resulting graph/digraph a <i>weighted graph/digraph</i><a href="part301.htm#bookmark1647" class="s23">. For example, we can draw a graph to represent major cities of a country connected by roads. In this graph, we can express the distance between two cities by adding weights to the edges. </a><a href="part301.htm#bookmark1647" class="s3">Figure </a><span class="s46">8.46</span>(c) shows a weighted graph.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">6. <b>Adjacent nodes. </b>Two nodes <i>i </i>and <i>j </i>of a graph are adjacent, if (<i>i, j</i>) is an edge in the graph.</p><p style="padding-top: 3pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;"><a href="part301.htm#bookmark1647" class="s23">In the graph of </a><a href="part301.htm#bookmark1647" class="s3">Figure </a><span class="s46">8.46</span>(a), nodes <i>a </i>and<i>b</i>, <i>a </i>and <i>c</i>, <i>a </i>and <i>d</i>, <i>b </i>and <i>d</i>, and <i>c </i>and <i>d </i><a href="part301.htm#bookmark1647" class="s23">are adjacent. However, in the digraph of </a><span class="s46">Figure 8.46</span>(b), <i>a </i>is adjacent to <i>b</i>, <i>a </i>is adjacent to <i>d</i>, <i>b </i>is adjacent to <i>d</i>, <i>c </i>is adjacent to <i>a</i>, and <i>d </i>is adjacent to <i>c</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 78pt;text-indent: 0pt;text-align: left;"><span><img width="476" height="323" alt="image" src="Image_540.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 152pt;text-indent: 0pt;text-align: left;"><a name="bookmark1647">Figure 8.46. </a><span class="s21">Examples of different types of graphs.</span></p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">7. <b>Path. </b><a href="part301.htm#bookmark1647" class="s23">A path is a sequence of nodes in which each node is adjacent to the next one. For example, in the graph of </a><span class="s46">Figure 8.46</span>(a), there are three paths from node <i>a </i>to node <i>c</i>. They are (<i>a, c</i>), (<i>a, d, c</i>) and (<i>a, b, d, c</i>). Similarly, (<i>b, a, c</i>), (<i>b, d, c</i>), (<i>b, a, d, c </i>) and (<i>b, d, a, c</i>) are the four paths from node <i>b </i>to node <i>c</i><a href="part301.htm#bookmark1647" class="s23">. However, in the digraph of </a><a href="part301.htm#bookmark1647" class="s3">Figure </a><span class="s46">8.46</span>(b), there is only one path from node <i>a </i>to node <i>c</i>, which is (<i>a, c</i>); and from node <i>b </i>to node <i>c</i>, which is ( <i>b, a, c</i>). This is because of the difference in the definition of adjacent nodes in graph and digraph.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">8. <b>Cycle. </b>A cycle is a path, whose start and end nodes are the same. For instance, (<i>a, b, d, a</i>), (<i>a, c, d, a </i>) and (<i>a, b, d, c, a</i><a href="part301.htm#bookmark1647" class="s23">) are examples of cycles in the graph of </a><span class="s46">Figure 8.46</span>(a); and (<i>a, c, d, a</i>) and (<i>a, c, d, b, a</i><a href="part301.htm#bookmark1647" class="s23">) are examples of cycles in the digraph of </a><span class="s46">Figure 8.46</span>(b).</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">9. <b>Loop. </b>A loop is a self-edge, which is of the form ( <i>i, i</i><a href="part301.htm#bookmark1647" class="s23">). It is a single edge, which starts and ends at the same node. </a><a href="part301.htm#bookmark1647" class="s3">Figure </a><span class="s46">8.46</span>(d) shows a digraph with a loop. Note that a graph/digraph cannot contain any loop because a valid edge connects two different nodes. However, loops are useful in some graphical representations in computer science. For example, we use loops in state transition diagrams.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -21pt;text-align: justify;">10. <b>Connected graph. </b><a href="part301.htm#bookmark1647" class="s23">A connected graph has a path from any node to any other node. The graph of </a><span class="s46">Figure 8.46</span>(a) is a connected graph.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">11. <b>Disconnected/disjoint graph.  </b><a href="part301.htm#bookmark1647" class="s23">A  graph,  which  is  not  a  connected  graph,  is  a disconnected/disjoint graph. In a disconnected/disjoint graph, certain groups of nodes form an island and do not have any connection with the rest of the graph. </a><a href="part301.htm#bookmark1647" class="s3">Figure </a><span class="s46">8.46</span>(e) shows two disconnected/disjoint graphs.</p><p style="padding-top: 4pt;padding-left: 17pt;text-indent: 0pt;text-align: justify;">12. <b>Complete graph/digraph. </b>A graph/digraph is complete when it has an edge between</p><p style="padding-top: 3pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">every pair of nodes. Notice that a complete graph with <i>n </i>nodes will have <i>n(n-1)/2 </i>edges, and a complete digraph with <i>n </i>nodes will have <i>n(n-1) </i><a href="part301.htm#bookmark1648" class="s23">edges. </a><a href="part301.htm#bookmark1648" class="s3">Figure </a><span class="s46">8.47</span> shows complete graphs for <i>n </i><a href="part301.htm#bookmark1649" class="s23">= 1, 2, 3 and 4. </a><span class="s46">Figure 8.48</span> shows complete diagraphs for <i>n </i>= 1, 2, 3 and 4.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 91pt;text-indent: 0pt;text-align: left;"><span><img width="439" height="149" alt="image" src="Image_541.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: center;"><a name="bookmark1648">Figure 8.47. </a><span class="s21">Complete graphs for n = 1, 2, 3 and 4. Number of edges in each = n(n-1)/2.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 97pt;text-indent: 0pt;text-align: left;"><span><img width="424" height="139" alt="image" src="Image_542.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: center;"><a name="bookmark1649">Figure 8.48. </a><span class="s21">Complete digraphs for n = 1, 2, 3 and 4. Number of edges in each = n(n-1).</span></p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;"><a name="bookmark1650">13. </a><b>Strongly and weakly connected digraphs. </b>A digraph is strongly connected, if there is a path from each node to every other node in it. That is, it has a path from <i>i </i>to <i>j </i>and from <i>j </i>to <i>i </i>for every pair of nodes <i>i </i>and <i>j</i><a href="part301.htm#bookmark1651" class="s23">. A digraph is weakly connected, if each node does not have a path to every other node in it. That is, in a weakly connected digraph there are at least two nodes </a><a href="part301.htm#bookmark1651" class="s33">i </a><a href="part301.htm#bookmark1651" class="s23">and </a><a href="part301.htm#bookmark1651" class="s33">j </a><a href="part301.htm#bookmark1651" class="s23">such that there is no path either from </a><a href="part301.htm#bookmark1651" class="s33">i </a><a href="part301.htm#bookmark1651" class="s23">to </a><a href="part301.htm#bookmark1651" class="s33">j </a><a href="part301.htm#bookmark1651" class="s23">or from </a><a href="part301.htm#bookmark1651" class="s33">j </a><a href="part301.htm#bookmark1651" class="s23">to </a><a href="part301.htm#bookmark1651" class="s33">i</a><a href="part301.htm#bookmark1651" class="s23">. </a><a href="part301.htm#bookmark1651" class="s3">Figure</a></p><p style="padding-left: 39pt;text-indent: 0pt;text-align: justify;"><a href="part301.htm#bookmark1651" class="s3">8.49</a><a href="part301.htm#bookmark1651" class="s24"> </a><a href="part301.htm#bookmark1651" class="s23">shows examples of strongly and weakly connected digraphs.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 100pt;text-indent: 0pt;text-align: left;"><span><img width="414" height="191" alt="image" src="Image_543.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: center;"><a name="bookmark1651">Figure 8.49. </a><span class="s21">Examples of strongly and weakly connected digraphs.</span></p><p style="padding-top: 8pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">14. <b>Subgraph. </b>If the set of nodes and set of edges of a graph <i>G1 </i>are subsets of the set of nodes and set of edges of another graph <i>G2</i>, then <i>G1 </i>is a subgraph of <i>G2</i><a href="part301.htm#bookmark1652" class="s23">. </a><a href="part301.htm#bookmark1652" class="s3">Figure </a><span class="s46">8.50</span> <a href="part301.htm#bookmark1652" class="s23">(b to i) are subgraphs of </a><span class="s46">Figure 8.50</span>(a).</p><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">15. <b>Spanning tree. </b>An undirected graph that is connected and has no cycles is a <i>tree</i>. A subgraph of a graph <i>G </i>that contains all the nodes of <i>G </i>and is a tree is a spanning tree of <i>G</i><a href="part301.htm#bookmark1652" class="s23">. </a><span class="s46">Figure 8.50</span> <a href="part301.htm#bookmark1652" class="s23">(f to i) are some spanning trees of the graph in </a><span class="s46">Figure 8.50</span>(a).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 66pt;text-indent: 0pt;text-align: left;"><span><img width="506" height="286" alt="image" src="Image_544.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 140pt;text-indent: 0pt;text-align: left;"><a name="bookmark1652">Figure 8.50. </a><span class="s21">Examples of subgraphs and spanning trees.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Representation of Graphs and Digraphs</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Adjacency matrix is the most frequently used representation for graphs and digraphs in computers.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Let <i>G(V, E) </i>be a graph in which <i>V </i>is the set of nodes (vertices) and <i>E </i>is the set of edges. Let the graph has <i>n </i>nodes and <i>V </i>= {<i>1, 2, …, n</i>}. Then the adjacency matrix of <i>G </i>is an <i>n </i>x <i>n </i>matrix <i>A</i>, in which each element is either zero or one defined in the following manner:</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1653">If </a><i>G </i>is an undirected graph, then</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 163pt;text-indent: 0pt;text-align: left;"><span><img width="204" height="34" alt="image" src="Image_545.jpg"/></span></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">If G is a digraph, then</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 187pt;text-indent: 0pt;text-align: left;"><span><img width="140" height="34" alt="image" src="Image_546.jpg"/></span></p><p class="s46" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part301.htm#bookmark1654" class="s3">Figure </a>8.51<span class="s10"> </span><a href="part301.htm#bookmark1647" class="s23">(a) and (b) show the adjacency matrices for the graph of </a><a href="part301.htm#bookmark1647" class="s3">Figure </a>8.46<a href="part301.htm#bookmark1647" class="s23">(a) and the digraph of </a>Figure 8.46<span class="p">(b), respectively.</span></p><p style="padding-left: 54pt;text-indent: 0pt;text-align: left;"><span><img width="495" height="216" alt="image" src="Image_547.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 36pt;text-indent: 0pt;text-align: left;"><a name="bookmark1654">Figure 8.51. </a><a href="part301.htm#bookmark1647" class="s42">Adjacency matrices for the graph of </a><span style=" color: #0000ED; font-family:&quot;Times New Roman&quot;, serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 10pt;">Figure 8.46</span><a href="part301.htm#bookmark1647" class="s42">(a) and the digraph of </a><span style=" color: #0000ED; font-family:&quot;Times New Roman&quot;, serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 10pt;">Figure 8.46</span><span class="s21">(b).</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">The adjacency matrix of a graph/digraph is subsequently stored using the method for storing arrays. There are several optimization methods on storage requirement for storing adjacency matrices of a graph/digraph. For example, notice that the adjacency matrix for undirected graphs is symmetric [<i>A (i, j) = A (j, i)</i>]. Hence, we need to explicitly store only the elements above (or below) the diagonal. Similarly, notice that all diagonal elements for the adjacency matrices of both undirected graphs and digraphs are zero. Hence, we need not store them.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Graph Search Methods</h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">In applications based on graphs, we often need to find things such as:</p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. Is there a path between two nodes <i>i </i>and <i>j </i>in a given graph/digraph?</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. Does a graph/digraph contain one or more cycles?</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3. Is a graph connected or disjoint?</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">4. Is a graph/digraph complete?</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">5. Is a digraph strongly or weakly connected?</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">6. Find one or more spanning trees of a graph.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Many of these functions require us to find out all nodes of a graph that can be reached (has a path) from a given node (start node). The two standard methods to do this are breadth-first search and depth-first search. They are described here.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1655">A graph/digraph often has multiple paths to a node from a given node (start node). Hence, while performing breadth-first search or depth-first search, we may arrive at the node from more than one direction. We must, therefore, ensure that we visit each node only once during the search process. The popular method to do this is to use a “Visited” flag at each node. This flag at each node is set to</a><i>OFF </i>before we start the search process, and is set to <i>ON </i>for a node as soon as we visit the node for the first time. We do not revisit a node, whose flag is <i>ON </i>even if we arrive at it again during the search process.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Out of the two, we use depth-first search method more frequently to obtain efficient algorithms for analyzing graphs.</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Breadth-first search. </b><a href="part301.htm#bookmark1656" class="s23">The example of </a><a href="part301.htm#bookmark1656" class="s3">Figure </a><span class="s46">8.52</span> illustrates the method. In this method, we pick up the starting node ( <i>D</i>) and determine the set of nodes adjacent to <i>D</i>, which is</p><p style="padding-left: 39pt;text-indent: 0pt;text-align: justify;">{<i>I</i>} for our example. We now pick up the nodes in this set one-by-one and determine the new nodes (nodes not yet visited) adjacent to each node in the set. The set of nodes adjacent to node <i>I </i>are {<i>G</i>, <i>R</i>}. We repeat this process until we find that there are no more adjacent nodes. For example, the set of new nodes adjacent to node <i>G </i>is {<i>A</i>} and adjacent to node <i>R </i>is {<i>P</i>}. Next, set of new nodes adjacent to node <i>A </i>is { <i>H</i>}, and set of new nodes adjacent to node <i>P </i>is null. Finally, set of new nodes adjacent to node <i>H </i>is null. Hence, the set of nodes reachable from starting node <i>D </i>is {<i>D</i>, <i>I</i>, <i>G</i>, <i>R</i>, <i>A</i>, <i>P</i>, <i>H</i>}.</p><p class="s46" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;"><a href="part301.htm#bookmark1656" class="s23">Normally, we use a queue to implement the breadth-first search algorithm. As we process each node, we place all of its adjacent nodes in the queue. We always pick up the node at the front of the queue as the next node in the search process. We delete a node from the queue when we pick it up for processing. </a><a href="part301.htm#bookmark1656" class="s3">Figure </a>8.52<span class="p">(b) shows the contents of the queue as we progress through the search process.</span></p><p class="s46" style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;"><a href="part301.htm#bookmark1656" class="s3">Figure </a>8.52<span class="p">(c) shows the subgraph formed by the edges used to reach the nodes visited during the search process.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 65pt;text-indent: 0pt;text-align: left;"><span><img width="509" height="456" alt="image" src="Image_548.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 113pt;text-indent: 0pt;text-align: left;"><a name="bookmark1656">Figure 8.52. </a><span class="s21">Example of breadth-first search method of graph search.</span></p><p style="padding-top: 8pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><a name="bookmark1657">2. </a><b>Depth-first search. </b>In this method, we select a node (starting node is selected first) and determine the set of new nodes (nodes not yet visited) adjacent to it. If this set is empty</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">(there is no new node adjacent to the selected node), the search terminates. Otherwise, we select the nodes in this set one-by-one and initiate a depth-first search for each, selecting the next node in the set when the depth-first search terminates for the previously selected node. The depth-first search for the graph terminates when we complete the depth-first search for all the nodes in the set.</p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Normally, we use a stack to implement depth-first search algorithm. The search process begins by pushing the first node (starting node) into the stack. We then pop the stack to select the next node for processing. After processing the selected node, we push all its adjacent new nodes into the stack. We repeat the above process until the stack becomes empty. The search process completes when the stack becomes empty.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part301.htm#bookmark1656" class="s23" name="bookmark1658">The same example of </a><a href="part301.htm#bookmark1656" class="s3">Figure </a><span class="s46">8.52</span><a href="part301.htm#bookmark1659" class="s23">(a), which is reproduced in </a><a href="part301.htm#bookmark1659" class="s3">Figure </a><span class="s46">8.53</span>(a), illustrates the method. We select the starting node <i>D </i>and push it into the stack. We then pop the stack to select node <i>D </i>for processing and push node <i>I </i>into the stack, which is the only new node adjacent to <i>D</i>. We now pop the stack to select node <i>I </i>for processing and push nodes <i>G </i>and<i>R </i>into the stack, which are the new nodes adjacent to <i>I</i>. We now pop the stack to select node <i>R </i>for processing and push nodes <i>A </i>and <i>P </i>into the stack, which are the new nodes adjacent to <i>R </i>(node <i>G </i>is not new since we have already visited it). We now pop the stack to select node <i>P </i>for processing and push node <i>H </i>into the stack, which is the new node adjacent to <i>P</i>. We now pop the stack to select node <i>H </i>for processing and do not push any node into the stack because there are no new nodes adjacent to <i>H</i>. We next pop the stack to select node <i>A </i>for processing and do not push any node into the stack because there are no new nodes adjacent to <i>A </i>(nodes <i>P </i>and <i>H </i>are not new since we have already visited them). We next pop the stack to select node <i>G </i>for processing and do not push any node into the stack because there are no new nodes adjacent to <i>G </i>(node <i>A </i>is not new since we have already visited it). As the stack is empty now, the search process terminates.</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"><span><img width="479" height="408" alt="image" src="Image_549.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1659">Figure 8.53. </a><span class="s21">Example of depth-first search method of graph search.</span></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part301.htm#bookmark1659" class="s3">Figure 8.53</a><a href="part301.htm#bookmark1659" class="s23">(b) shows the contents of the stack as we progress through the search process. </a><a href="part301.htm#bookmark1659" class="s3">Figure</a><a href="part301.htm#bookmark1659" class="s24"> </a><a href="part301.htm#bookmark1659" class="s3">8.53</a><a href="part301.htm#bookmark1659" class="s23">(c) shows the subgraph formed by the edges used to reach the nodes visited during </a>the search process.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Operations for Handling Graphs/Digraphs</h4><p class="s46" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Figures 8.54<span class="s10"> </span><a href="part301.htm#bookmark1661" class="s23">and </a>8.55<span class="s10"> </span><span class="p">list the commonly supported operations for handling graphs and digraphs, respectively.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 79pt;text-indent: 0pt;text-align: left;"><span><img width="428" height="177" alt="image" src="Image_550.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1660">Figure 8.54. </a><span class="s21">Commonly supported operations for handling graphs (undirected).</span></p><p style="padding-left: 76pt;text-indent: 0pt;text-align: left;"><span><img width="438" height="200" alt="image" src="Image_551.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1661">Figure 8.55. </a><span class="s21">Commonly supported operations for handling digraphs.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Uses of Graphs</h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Graphs are a convenient means of expressing problems that involve relationships between objects, places, or concepts. For instance, we can describe who knows whom in a room as a collection of nodes, each representing a person, and directed edges from a node to other nodes representing all the persons whom that person (represented by the node) knows. Representation of such abstract problems as graphs simplifies the process of creating mental models of problems, which in turn leads to better problem solving. Hence, we often use graphs for modeling and analysis of a variety of situations such as:</p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. Analysis of electrical and computer networks.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. Study of molecular structure of chemical compounds.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">3. Representation of routes in airline network, railway network, road network, or communication network.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><a name="bookmark1662">4. Representation of dependencies among modules of software.</a></p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">5. Representation of dependencies among various activities of a project for better project planning.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">6. In genetic studies.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Modeling a problem as a graph often presents new approaches to solve the problem or even leads directly to a solution derived from graph theory.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part300.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part302.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
