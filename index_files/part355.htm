<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Mutual Exclusion</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part354.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part356.htm">Далее &gt;</a></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark353" name="bookmark1814">Mutual Exclusion</a><a name="bookmark1895">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">There are several resources in a system that multiple processes must not use simultaneously, if program operation is to be correct. For example, multiple processes must not update a file simultaneously. Similarly, operating systems must restrict use of unit record peripherals such as tape drives or printers to a single process at a time. Therefore, an operating system must ensure exclusive access to such a shared resource by a process. This exclusiveness of access is called <i>mutual exclusion </i>between processes. We refer to the sections of a program that need exclusive access to shared resources as <i>critical sections. </i>For mutual exclusion, operating systems implement mechanisms to prevent processes from executing concurrently within their associated critical sections.</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">An algorithm for implementing mutual exclusion must satisfy the following requirements:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. <b>Mutual exclusion. </b>Given a shared resource, which multiple concurrent processes can access, at any time, only one process must access the resource. That is, if the operating system grants the resource to a process, the process must release it before the operating system can grant it to another process.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. <b>No starvation. </b>If every process to which the operating system grants the resource eventually releases it, the operating system must eventually grant the resource to every process requesting it.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Two commonly used approaches, which modern operating systems use to implement mutual exclusion are test-and-set and semaphore. They are described here.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Test-and-Set</h4><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part355.htm#bookmark1897" class="s3">Figure </a><span class="s46">10.12</span> shows the basic concept behind test-and-set method of implementing mutual exclusion. The mechanism uses a global Boolean variable <i>lock</i>, which it initializes to <i>false</i>. It also uses an atomic instruction <i>test-and-set</i>, which tests the<i>lock </i>status and sets it to <i>true, </i>if it is <i>false </i>at the time of testing.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Test-and-set is an atomic instruction, which means that the mechanism executes both testing of</p><p class="s16" style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">lock <span class="p">variable status and setting it to </span>true <span class="p">(if it is </span>false<span class="p">) as one uninterruptible unit.</span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part355.htm#bookmark1897" class="s23">As </a><a href="part355.htm#bookmark1897" class="s3">Figure </a><span class="s46">10.12</span> shows, when a process (<i>P1</i>) wants to enter critical section, it executes <i>test-and- set </i>instruction. If the status of <i>lock </i>variable is <i>false</i>, it is set to<i>true </i>by the <i>test-and-set </i>instruction. Now <i>P 1 </i>enters critical section and executes the instructions in critical section. Notice that during this period, if another process ( <i>P</i><i>2</i>) wants to enter critical section, it will also execute <i>test-and-set</i></p><p class="s16" style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1896"><span class="p">instruction, but will find the status of </span></a>lock <span class="p">variable to be </span>true <span class="p">(the test “Is lock = false?” returns No). Hence, it will go to </span>wait <span class="p">state. When </span>P1 <span class="p">completes executing its critical section, it sets </span>lock <span class="p">variable to </span>false <span class="p">and sends interrupt signal to the operating system, indicating completion of execution of its critical section. The operating system then sends a wakeup signal to the waiting process </span>P<span class="s44">2</span><span class="p">. When </span>P<span class="s44">2</span> <span class="p">executes </span>test- and-set <span class="p">instruction this time, </span>test-and-set <span class="p">instruction will find</span></p><p class="s16" style="padding-top: 2pt;padding-left: 6pt;text-indent: 0pt;line-height: 117%;text-align: justify;">lock <span class="p">variable to be </span>false <span class="p">and will set it to </span>true<span class="p">. Therefore, </span>P<span class="s44">2</span> <span class="p">can enter its critical section this time.</span></p><p style="padding-left: 142pt;text-indent: 0pt;text-align: left;"><a name="bookmark1898"><span><img width="261" height="390" alt="image" src="Image_618.jpg"/></span></a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1897">Figure 10.12. </a><span class="s21">Test-and-set method of implementing mutual exclusion.</span></p><p class="s16" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><span class="p">In this manner, </span>test-and-set <span class="p">mechanism ensures that only one process out of multiple processes trying to share a mutually exclusive resource will execute in its critical section at a time. If multiple processes try to enter their critical sections during the period in which </span>P<span class="s44">1</span> <span class="p">is executing its</span></p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;line-height: 109%;text-align: justify;">critical section, all of them will go to <i>wait </i>state like <i>P</i><i>2</i>. To ensure that no waiting process starves for the resource indefinitely, and all waiting processes get the resource eventually, the operating system maintains a waiting queue of all processes waiting on <i>lock </i>variable, and grants them the</p><p style="padding-left: 5pt;text-indent: 0pt;line-height: 13pt;text-align: justify;">resource in first-come-first-served order.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Semaphore</h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Test-and-set mechanism of handling mutual exclusion problem is suitable for resources that have only one unit in a system. We cannot generalize it easily to handle mutual exclusion problem for resources that have multiple units in a system. Semaphore mechanism can handle mutual exclusion problem for such resources.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">A semaphore (say <i>S</i>) is a global integer variable with the following features:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">1. The mechanism initializes it to the total number of units of the resource (to which it is to provide synchronized access).</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. The mechanism allows its access only through two standard atomic operations <i>wait </i>and</p><p class="s16" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">signal<a href="part355.htm#bookmark1899" class="s23">. </a><span class="s46">Figure 10.13</span><span class="s10"> </span><span class="p">shows the activities performed by the two operations.</span></p><p style="padding-left: 99pt;text-indent: 0pt;text-align: left;"><span><img width="377" height="397" alt="image" src="Image_619.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1899">Figure 10.13. </a><span class="s21">Semaphore method of implementing mutual exclusion.</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part355.htm#bookmark1899" class="s23">As </a><a href="part355.htm#bookmark1899" class="s3">Figure </a><span class="s46">10.13</span> shows, when a process <i>P1 </i>wants to enter critical section, it executes <i>wait </i>atomic operation on semaphore <i>S</i>. It tests if value of semaphore <i>S </i>is greater than zero and decrements its value by one if <i>S&gt;0</i>. Now <i>P1 </i>enters critical section and executes the instructions in critical section. Notice that during this period, if another process (<i>P</i><i>2</i>) wants to enter critical section, it</p><p style="padding-top: 2pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">will also execute <i>wait </i>operation on semaphore <i>S</i>. Since the mechanism initializes the value of <i>S </i>to total units of the mutually exclusive resource, if there are multiple units of the resource, <i>P2 </i>will also find that the value of semaphore <i>S </i>is greater than zero. Hence, it will decrement its value by one and enter the critical section. In this manner, if there are <i>n </i>units of the resource, <i>n </i>processes can enter their critical sections simultaneously. If <i>(n+1)</i><span class="s31">th </span>process wants to enter critical section and executes <i>wait </i>operation on semaphore <i>S</i>, the test “Is <i>S&gt;0</i>” will return <i>false</i>, and the process will go to <i>wait </i>status.</p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">When a process completes executing its critical section, it executes <i>signal </i>operation on semaphore <i>S</i>, which increments the value of <i>S </i>by one to indicate that one more unit of the resource has become free for allocation. The process then sends an interrupt signal to the operating system, indicating completion of execution of its critical section. The operating system then sends a wakeup signal to the first process in the waiting queue, which now executes <i>wait </i>operation on semaphore <i>S </i>once again and enters its critical section.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">In this manner, semaphore mechanism ensures that up to <i>n </i>processes only (<i>n </i>is the number of units of the mutually exclusive resource) can execute their critical sections simultaneously.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The semaphore described above is known as <i>counting semaphore</i>, since its integer value can range over an unrestricted domain. Note that if the value of <i>S </i>is initialized to 1 for a counting</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">semaphore, its value can range only between 0 and 1. Such a semaphore is known as <i>binary semaphore</i>. A binary semaphore is suitable for synchronizing access to those mutually exclusive resources that have only one unit in a system. Hence, a binary semaphore serves the purpose of test-and-set approach of implementing mutual exclusion.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part354.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part356.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
