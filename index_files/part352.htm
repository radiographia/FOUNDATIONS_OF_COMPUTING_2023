<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Multithreading</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part351.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part353.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark350" name="bookmark1811">Multithreading</a><a name="bookmark1882">&zwnj;</a></p><p class="s16" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1883">Threads </a><a href="part352.htm#bookmark1884" class="s23">are a popular way to improve application performance. In traditional operating systems, the basic unit of CPU utilization is a process. Each process has its own program counter, its own register states, its own stack, and its own address space (memory area allocated to it). On the other hand, in operating systems with threads facility, the basic unit of CPU utilization is a thread. In these operating systems, a process consists of an address space and one or more threads of control [see </a><a href="part352.htm#bookmark1884" class="s3">Figure </a><span class="s46">10.7</span><span class="p">]. Each thread of a process has its own program counter, its own register states, and its own stack. However, all the threads of a process share the same address space. Hence, they also share the same global variables. In addition, all threads of a process also share the same set of operating system resources, such as open files, signals, accounting information, etc. Due to sharing of address space, there is no protection between the threads of a process. However, protection between multiple threads of a process is not necessary because a single user always owns a process (and hence all its threads). Multiple processes need protection against each other because different processes may belong to different users.</span></p><p style="padding-left: 119pt;text-indent: 0pt;text-align: left;"><span><img width="322" height="142" alt="image" src="Image_613.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1884">Figure 10.7. </a><span class="s21">(a) Single-threaded and (b) multi-threaded processes. A single-threaded process corresponds to a process of a traditional operating system. [Reproduced with permission, from the book titled Distributed Operating Systems: Concepts and Design by Pradeep K. Sinha. © 1997 IEEE, USA].</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part352.htm#bookmark1884" class="s23">Threads share a CPU in the same way as processes do. At a particular instance of time, a thread is in running, blocked, ready, or terminated state. Due to these similarities, users often view threads as miniprocesses. In fact, in operating systems with threads facility, a process having a single thread corresponds to a process of a traditional operating system [see </a><a href="part352.htm#bookmark1884" class="s3">Figure </a><span class="s46">10.7</span>(a)]. We often refer to threads as <i>lightweight processes </i>and traditional processes as <i>heavyweight processes</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Motivations for Using Threads</h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">The main motivations for using a multi-threaded process instead of multiple single-threaded processes for performing some computation are as follows:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. The overhead involved in creating a new process is considerably greater than that for creating a new thread within a process. This is because when the operating system creates a new process, it has to create its address space from scratch, although the new process may inherit a part of its address space from its parent process. On the other hand, when the operating system creates a new thread, it need not create an address space for it because the new thread uses the address space of its process.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. Due to sharing of address space and other operating system resources among the threads of a process, the overhead involved in CPU switching among peer threads is small as compared to CPU switching among processes having their own address spaces. This is the reason why threads are called lightweight processes.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">3. An operating system can share resources more efficiently among multiple threads of a process than among multiple processes because all threads of a process share the same address space.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Finally, users find the threads model more intuitive for application programming because a set of threads using a shared address space is the most natural way to program many applications. For example, in an application, which uses producer-consumer model, the producer and consumer processes must share a common buffer. Therefore, programming the application in such a way that the producer and consumer are two threads of the same process makes the software design simpler.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part351.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part353.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
