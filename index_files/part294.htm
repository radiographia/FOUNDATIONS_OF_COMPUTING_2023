<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Linked List</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part293.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part295.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark292" name="bookmark1523">Linked List</a><a name="bookmark1608">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">A <i>linked list </i><a href="part294.htm#bookmark1609" class="s23">consists of a set of nodes linked together. Each node has two basic fields - data field and pointer field (see </a><a href="part294.htm#bookmark1609" class="s3">Figure </a><span class="s46">8.26</span>). The data field contains the data, while the pointer field links the node to another node belonging to the same linked list. The data field itself may have multiple sub-fields when each node stores multiple data elements. Depending on the type of linked list, the pointer field may have only one pointer (single-linked lists) or two pointers (doubly-linked lists). In addition to the nodes, a linked list has a pointer called “head”, which points to the first node of the linked list. It enables us to keep track of the list. Some implementations of linked lists also use a “tail” pointer, which points to the last node of the linked list. This makes adding of elements to the tail of a list more efficient.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 54pt;text-indent: 0pt;text-align: left;"><span><img width="494" height="155" alt="image" src="Image_520.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1609">Figure 8.26. </a><span class="s21">Linked list.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: center;">The main advantage of a linked list over a conventional array is that the order of the data elements in a linked list may be different from the order in which a computer stores the data</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">elements in memory or on disk, allowing traversal of the data elements in a different order. Recall that the data elements of an array are stored in contiguous memory locations. Of course, this advantage of linked list comes at the cost of storing a pointer field with each data element, which requires additional storage space for the pointers. Linked lists also have the flexibility to grow and shrink dynamically because they permit insertion and removal of nodes at any point in the linked list. For a newly added node to a linked list, a computer can allocate the required memory space wherever it is available because a linked list does not require contiguous memory space for storage of its nodes.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Some programming languages, such as LISP and Scheme, support linked list as a built in data structure with operations to access, insert, and remove data elements from linked lists. Other programming language, such as C, C++ and Java, rely on the use of primitive data types and language supported address referencing mechanism to create linked lists.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1610">Types of Linked Lists</a></h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Many different types of linked lists exist. Three of the commonly used types are:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. <b>Singly-linked list. </b><a href="part294.htm#bookmark1611" class="s23">In its basic form, each node of a singly-linked list points to its successor node and the pointer of the last node is a NULL pointer [see </a><a href="part294.htm#bookmark1611" class="s3">Figure </a><span class="s46">8.27</span>(a)]. The “head” pointer points to the first node, and we use it to keep track of the list.</p><p class="s46" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;"><a href="part294.htm#bookmark1611" class="s23">Inserting a new node at the head of a list is efficient because of the “head” pointer. However, for adding a node at the end of the list (after the last node), we need to locate the last node first, for which the entire list needs to be traversed, which is inefficient for lists with large number of nodes. To solve this problem, we use a “tail” pointer, which points to the last node of a list [see </a><a href="part294.htm#bookmark1611" class="s3">Figure </a>8.27<span class="p">(b)]. This simple enhancement allows efficient execution of both “prepend” and “append” operations.</span></p><p style="padding-left: 79pt;text-indent: 0pt;text-align: left;"><span><img width="471" height="410" alt="image" src="Image_521.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 155pt;text-indent: 0pt;text-align: left;"><a name="bookmark1611">Figure 8.27. </a><span class="s21">Commonly used types of linked lists.</span></p><p style="padding-top: 8pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. <b>Singly-linked circular list. </b>Each node of a singly-linked circular list (or simply <i>circular list</i><a href="part294.htm#bookmark1611" class="s23">) points to its successor node and the pointer of the last node points to the first node (instead of being a NULL pointer). The “head” pointer also points to the first node. </a><a href="part294.htm#bookmark1611" class="s3">Figure</a><a href="part294.htm#bookmark1611" class="s24"> </a><a href="part294.htm#bookmark1611" class="s3">8.27</a><a href="part294.htm#bookmark1611" class="s23">(c) shows a circular list. Use of circular list instead of singly-linked list </a>often simplifies an application code and makes the application run faster.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. <b>Doubly-linked list. </b><a href="part294.htm#bookmark1611" class="s23">Each node of a doubly-linked list has two pointers - “left” and “right”. The left pointer of a node points to its left neighbour (if any) and the right pointer points to its right neighbour (if any). The left pointer of the leftmost node and the right pointer of the rightmost node are NULL pointers. The “head” pointer points to the first node. </a><a href="part294.htm#bookmark1611" class="s3">Figure</a><a href="part294.htm#bookmark1611" class="s24"> </a><a href="part294.htm#bookmark1611" class="s3">8.27</a><a href="part294.htm#bookmark1611" class="s23">(d) shows a doubly-linked list. Some applications are more convenient to </a>program with a doubly-linked list than with a singly-linked list or a circular list.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1612">Operations for Handling Linked Lists</a></h4><p class="s46" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part294.htm#bookmark1613" class="s3">Figure </a>8.28<span class="s10"> </span><span class="p">lists some commonly supported operations for handling linked lists. Note that all programming languages that support linked list do not necessarily support all these operations and some programming languages may support additional operations.</span></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"><a name="bookmark1616"><span><img width="481" height="169" alt="image" src="Image_522.jpg"/></span></a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1613">Figure 8.28. </a><span class="s21">Some commonly supported operations for handling linked lists.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Uses of Linked Lists</h4><p class="s46" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part293.htm#bookmark1607" class="s23">We use linked lists primarily for list processing applications, in which we need to represent symbolic data in the form of lists (collection of non-contiguous memory cells linked together with pointers). Compiler development, pattern recognition, games simulation, and Artificial Intelligence (AI) applications need such data representation and their handling capability. We also use linked lists to implement other data structures (such as the one in </a><a href="part293.htm#bookmark1607" class="s3">Figure </a>8.25<span class="p">).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part293.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part295.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
