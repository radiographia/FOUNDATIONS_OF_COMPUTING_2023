<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Pseudocodes for Basic Logic (Control) Structures</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part286.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part288.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark285" name="bookmark1516">Pseudocodes for Basic Logic (Control) Structures</a><a name="bookmark1580">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">During early days of program development, many programmers developed program logics for large programs with mazes of branches (jumps from one portion of the program to another) that altered the sequence of processing operations. Such programs are now referred to as “spaghetti code” because their program flowcharts appeared more like a plate of spaghetti than like logical analyses of programming problems. Understanding the logic of such programs was difficult for someone other than the developer, and even for the developer after a lapse of few months. Hence, these programs were difficult to modify for incorporating suggested enhancements, and became nightmares for those responsible for their maintenance.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Researchers later proved that it is possible to express any program logic, no matter how complex, by using only the following three simple logic (control) structures:</p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. Sequence logic</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. Selection logic</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3. Iteration (or looping) logic</p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">They also proved that programs structured by using only these three logic structures are easier to understand, because we can read them from top to bottom. That is, by conceptualizing the logic of a program in the form of these three logic structures, programmers can avoid writing spaghetti code, and produce programs that are easy to understand and maintain. This also helps in reducing program errors and the time spent in program testing. Writing of programs by using these three basic control structures soon became widely accepted as a more scientific approach to solving a programming problem, and was termed <i>structured programming </i>technique.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">As good programming practices, it recommended that programmers should develop program logics and write programs using the three basic logic structures. Therefore, we present here the pseudocodes for the three basic logic structures (along with their flowcharts for those who are more comfortable with flowcharts).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1581">Sequence Logic</a></h4><p class="s16" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Sequence logic <a href="part287.htm#bookmark1582" class="s23">performs instructions one after another in sequence. Thus, for writing pseudocode instructions for sequence logic, we write the instructions in the order (or sequence) of their execution. Logic flow of psuedocode is from top to bottom. </a><a href="part287.htm#bookmark1582" class="s3">Figure </a><span class="s46">8.14</span><span class="s10"> </span><span class="p">shows an</span></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1585">example of sequence logic structure.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 145pt;text-indent: 0pt;text-align: left;"><span><img width="251" height="146" alt="image" src="Image_507.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1582">Figure 8.14. </a><span class="s21">Flowchart and pseudocode for sequence structure.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Selection Logic</h4><p class="s46" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><span class="s16">Selection logic</span><span class="p">, also known as </span><span class="s16">decision logic</span><a href="part287.htm#bookmark1583" class="s23">, makes decisions. It selects a path out of two or more paths in program logic. We depict selection logic as an IF…THEN…ELSE, or an IF… THEN, or a CASE structure. The flowcharts of </a><a href="part287.htm#bookmark1583" class="s3">Figures </a>8.15<a href="part287.htm#bookmark1584" class="s23">, </a>8.16<a href="part287.htm#bookmark1586" class="s23">, and </a>8.17<span class="p">, respectively illustrate the logic of these structures along with their corresponding pseudocodes.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 83pt;text-indent: 0pt;text-align: left;"><span><img width="418" height="166" alt="image" src="Image_508.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1583">Figure 8.15. </a><span class="s21">Flowchart and pseudocode for IF…THEN…ELSE selection structure.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 81pt;text-indent: 0pt;text-align: left;"><span><img width="424" height="158" alt="image" src="Image_509.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1584">Figure 8.16. </a><span class="s21">Flowchart and pseudocode for IF…THEN selection structure.</span></p><p style="padding-left: 67pt;text-indent: 0pt;text-align: left;"><span><img width="459" height="256" alt="image" src="Image_510.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1586">Figure 8.17. </a><span class="s21">Flowchart and pseudocode for CASE selection structure.</span></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">IF…THEN…ELSE structure means that if the condition is true, then do Process 1, else (if the condition is not true) do Process 2. Hence, program logic executes either Process 1 or Process 2 depending on whether the specified condition is true or false. However, if we do not want to choose between two processes, and simply want to decide whether to execute a process or not, then we use IF…THEN structure. IF…THEN structure means that if the condition is true, then do Process 1, otherwise (if the condition is not true) skip over Process 1.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part287.htm#bookmark1586" class="s23">CASE structure represents multiple-way selection logic. It allows choosing from more than two control paths in a program logic enabling selection of one of any number of statements or statement groups. The CASE statement of </a><a href="part287.htm#bookmark1586" class="s3">Figure </a><span class="s46">8.17</span> indicates that if the value of <i>Type </i>is equal to Type-1, execute Process 1, if it is equal to Type-2, execute Process 2, if it is equal to Type-3, execute Process 3, and so on.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">In all these structures, Process 1, Process 2, Process 3, etc. can be one or more processes. They are not limited to a single process. In case of IF…THEN and IF…THEN…ELSE decision structures, ENDIF indicates their end; and in case of CASE structure, ENDCASE indicates its end.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Iteration (or Looping) Logic</h4><p class="s46" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><span class="s16">Iteration logic </span><a href="part287.htm#bookmark1587" class="s23">produces loops in program logic whenever there is a need to execute one or more instructions several times depending on some condition. It uses two structures called DO… WHILE and REPEAT…UNTIL. </a><a href="part287.htm#bookmark1587" class="s3">Figures </a>8.18<span class="s10"> </span><a href="part287.htm#bookmark1589" class="s23">and </a>8.19<span class="s10"> </span><span class="p">show the flowcharts and pseudocodes for DO…WHILE and REPEAT…UNTIL structures respectively. As both DO…WHILE and REPEAT…UNTIL are used for looping, it is important to know the difference between the two structures. In DO…WHILE, looping continues as long as the condition is true, and stops when the condition is not true. Since program logic tests the condition for looping at the beginning of the loop, if the condition is false when it first encounters the loop, it will not execute the statements in the loop at all (not even once). On the other hand, in REPEAT…UNTIL, looping continues until the condition becomes true. That is, program logic repeats execution of statements within the loop as long as the condition is not true. Since it tests the condition for looping at the end of the loop, it will execute the statements in the loop at least once.</span></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">In both DO…WHILE and REPEAT…UNTIL, the loop must contain a statement, which changes the condition that controls the loop. If it does not, looping will continue without end, becoming an infinite loop. Remember that, no program should contain an infinite loop. ENDDO marks the end of a DO…WHILE structure, and UNTIL followed by some condition marks the end of a REPEAT...UNTIL structure.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 85pt;text-indent: 0pt;text-align: left;"><span><img width="412" height="247" alt="image" src="Image_511.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1587">Figure 8.18. </a><span class="s21">Flowchart and pseudocode for DO…WHILE iteration structure.</span><a name="bookmark1588">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 84pt;text-indent: 0pt;text-align: left;"><span><img width="415" height="214" alt="image" src="Image_512.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1589">Figure 8.19. </a><span class="s21">Flowchart and pseudocode for REPEAT…UNTIL iteration structure.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part286.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part288.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
