<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Multiprogramming</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part349.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part351.htm">Далее &gt;</a></p><p style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark348" name="bookmark1809">Multiprogramming</a><a name="bookmark1873">&zwnj;</a></p><p class="s46" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part350.htm#bookmark1875" class="s23">Both manual loading and batch processing systems load and process one job at a time. After such a system loads a job, the job remains in main memory until its execution is over, and the system loads the next job only after completion of the current job. </a><a href="part350.htm#bookmark1875" class="s3">Figure </a>10.3<span class="s10"> </span><a href="part350.htm#bookmark1875" class="s23">shows that in such a situation, the job that is currently loaded in the system is the sole occupant of user&#39;s area of main memory (operating system resides in a separate part of main memory) and has the CPU available exclusively for its execution. </a><a href="part350.htm#bookmark1875" class="s3">Figure </a>10.3<span class="s10"> </span><span class="p">illustrates a </span><span class="s16">uniprogramming system, </span><span class="p">which processes only one job at a time, and all system resources are available exclusively for the job until its completion.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">A job does not need CPU for entire duration of its processing because in addition to computing (for which CPU is needed), it often needs to perform I/O operations (such as reading/writing of data from/to tape/disk, waiting for data input from keyboard/mouse, and printing of results) during the course of its processing. In fact, depending on CPU utilization during the course of processing, jobs are of two types:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. <b>CPU-bound jobs. </b>These jobs mostly perform computations with little I/O operations. Hence, their CPU utilization is high. Jobs for scientific and engineering applications usually fall in this category.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. <b>I/O-bound jobs. </b>These jobs mostly perform I/O operations with little computation. Hence, their CPU utilization is low. Jobs for commercial data processing applications usually fall in this category.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1874">In a uniprogramming system, CPU is idle whenever the job executing currently performs I/O operations. CPU idle time may not be significant for CPU-bound jobs, but it may be of the order of 80-90% for I/O-bound jobs. Moreover, since I/O devices are slower than CPU by 20 to 100 times, CPU idle time is significant even for CPU-bound jobs. To minimize the idle time of CPU,</a></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">researchers introduced the concept of multiprogramming, which uses the idea of organizing multiple jobs in a system so that its CPU always has something to execute. How a system does this is explained here.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 150pt;text-indent: 0pt;text-align: left;"><span><img width="239" height="194" alt="image" src="Image_609.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 88pt;text-indent: -80pt;text-align: left;"><a name="bookmark1875">Figure 10.3. </a><span class="s21">Uniprogramming system model. A uniprogramming system processes only one job at a time, and all system resources are available exclusively for the job until its completion.</span></p><p class="s16" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Multiprogramming <a href="part350.htm#bookmark1875" class="s23">is interleaved execution of two or more different and independent programs by a computer. </a><a href="part350.htm#bookmark1875" class="s3">Figure </a><span class="s46">10.3</span><span class="s10"> </span><span class="p">has already introduced the notion of two programs (operating system and user program) resident simultaneously in main memory of a computer. This concept is carried a step further in multiprogramming by enabling two or more user programs to reside simultaneously in main memory and carrying out their interleaved execution. With multiple user programs residing simultaneously in the user program area of main memory, whenever a user program that was executing (using CPU) goes to perform I/O operations, the operating system allocates the CPU to another user program in main memory that is ready to use it, instead of allowing the CPU to remain idle. The CPU switches from one program to another almost instantaneously. Hence, in multiprogramming, several user programs share CPU time to keep it busy.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Note that multiprogramming does not mean execution of instructions from several programs simultaneously. Rather, it means that multiple programs are available to CPU (stored in main memory) and a portion of one is executed, then a portion of another, and so on. As a CPU can execute only one instruction at a time, only one of the programs residing in main memory uses the CPU for executing its instructions at any instance of time. Simultaneous execution of more than one program with a single CPU is impossible. Some multiprogramming systems process only a fixed number of jobs concurrently ( <i>multiprogramming with fixed tasks </i>- MFT), while others can process variable number of jobs concurrently ( <i>multiprogramming with variable tasks</i></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">- MVT).</p><p class="s46" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part350.htm#bookmark1876" class="s3">Figure </a>10.4<span class="s10"> </span><a href="part350.htm#bookmark1878" class="s23">shows a typical scenario of jobs in a multiprogramming system. At the time instance shown, there are three user jobs (A, B, and C) residing in memory out of which job A is performing I/O operation (writing to disk), job B is executing (utilizing CPU time), and job C is waiting for CPU to become free. As </a><a href="part350.htm#bookmark1878" class="s3">Figure </a>10.5<span class="s10"> </span><span class="p">shows, in case of multiprogramming, all jobs residing in main memory are in one of the following three states:</span></p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. Running (it is using CPU)</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. Blocked (it is performing I/O operations)</p><p style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3. Ready (it is waiting for allocation of CPU to it)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 129pt;text-indent: 0pt;text-align: left;"><span><img width="295" height="218" alt="image" src="Image_610.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1876">Figure 10.4. </a><span class="s21">A typical scenario of jobs in a multiprogramming system.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part350.htm#bookmark1876" class="s23">In </a><a href="part350.htm#bookmark1876" class="s3">Figure </a>10.4<span class="p">, jobs A, B, and C are in blocked, running, and ready states, respectively. As soon as job B relinquishes the CPU (either its execution is over or it needs to perform some I/O operation), the CPU is given to job C (because it is in ready state) and it starts executing. Meanwhile, if job A completes output operation, its state converts from blocked to ready. Hence, in multiprogramming, CPU is never idle as long as there is always some job to execute.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1877">Note that although many jobs may be in ready and blocked states, only one job can be running at any instance of time, because there is only one CPU.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 105pt;text-indent: 0pt;text-align: left;"><span><img width="358" height="140" alt="image" src="Image_611.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1878">Figure 10.5. </a><span class="s21">Three different states of jobs in main memory in a multiprogramming system.</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">The area occupied by each job residing simultaneously in main memory is known as a <i>memory partition</i>. The number of partitions, and hence number of jobs, which a system can concurrently load in its main memory at any given time depends on its operating system. The operating system maintains a queue of jobs awaiting entry into main memory. The jobs themselves reside on a fast secondary storage device such as magnetic disk. The operating system picks up a job from this queue and loads it from secondary storage into main memory whenever a memory partition becomes free (the job occupying that partition completes its execution).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Requirements of Multiprogramming Systems</h4><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Multiprogramming systems have better throughput than uniprogramming systems because multiprogramming reduces CPU idle time significantly. However, they are more sophisticated because they require the following additional hardware and software features:</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Large memory. </b>Multiprogramming requires large main memory to accommodate a good number of user programs along with the operating system.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. <b>Memory protection. </b>Multiprogramming requires a memory protection mechanism to prevent a job (in one memory partition) from changing another job&#39;s program/data (in another memory partition). Operating systems use a combination of hardware and software protection mechanisms for preventing one job from addressing beyond the limits of its own allocated memory area.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. <b>Job status preservation. </b>In multiprogramming, when the operating system blocks a running job because the job needs to do I/O processing, it takes CPU away from the job and gives it to another job that is ready for execution. The blocked job resumes its execution sometime later. To enable this, the operating system must preserve the job&#39;s status information when it takes away the CPU from it, and must restore this information back before it gives the CPU to the job again. For this, the operating system maintains a <i>process control block </i><a href="part350.htm#bookmark1880" class="s23">(PCB) for each process, which is loaded in a memory partition. </a><a href="part350.htm#bookmark1880" class="s3">Figure </a><span class="s46">10.6</span> shows a typical process control block. With this arrangement, before taking away the CPU from a running process, the operating system preserves its status in its PCB. The operating system restores back the status of this process just before it gives back the CPU to it again later to resume its execution. Hence, the process can continue execution without any problem.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><a name="bookmark1879">4. </a><b>Proper job mix. </b>A multiprogramming system requires a proper mix of I/O-bound and CPU-bound jobs to overlap the operations of CPU and I/O devices effectively. If all loaded jobs need I/O at the same time, CPU will again be idle. Hence, jobs resident simultaneously in main memory should be a good mix of CPU-bound and I/O-bound jobs so that at least one job is always ready to utilize the CPU.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 202pt;text-indent: 0pt;text-align: left;"><span><img width="142" height="176" alt="image" src="Image_612.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 150pt;text-indent: 0pt;text-align: left;"><a name="bookmark1880">Figure 10.6. </a><span class="s21">A typical process control block (PCB).</span></p><p style="padding-top: 8pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">5. <b>CPU scheduling. </b>In a multiprogramming system, often there are multiple jobs in ready state (waiting for the operating system to allocate the CPU to it). Hence, when the CPU becomes free, the operating system must have a mechanism to decide to which one of these ready jobs it should allocate the CPU. Part of the operating system that takes this decision is called <i>CPU scheduler</i>, and the algorithm it uses for this is called <i>CPU scheduling algorithm</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part349.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part351.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
