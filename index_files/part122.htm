<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Dual Bus Architecture</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part121.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part123.htm">Далее &gt;</a></p><p style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark120" class="s28" name="bookmark940">Dual Bus Architecture</a><a name="bookmark1006">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><span><img width="75" height="1" alt="image" src="Image_323.png"/></span></p><p class="s10" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part122.htm#bookmark1007" class="s23">In dual bus architecture, there are separate sets of buses for interconnecting the CPU with memory and I/O devices (see </a><a href="part122.htm#bookmark1007" class="s24">Figure </a>4.12<span style=" color: #000;">). Hence, a system having this architecture transfers data between the CPU and memory by using one set of buses, while it transfers data between the CPU and I/O devices by using another set of buses. In this case, a system uses one of the following two mechanisms for data transfer between the CPU and an I/O device:</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 81pt;text-indent: 0pt;text-align: left;"><span><img width="423" height="106" alt="image" src="Image_324.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1007">Figure 4.12. </a><span class="s21">Dual bus interconnection architecture.</span><a name="bookmark1008">&zwnj;</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. <b>Busy wait. </b>In this method, the CPU sends the I/O request (say a data READ request) to the device via the buses. It sends the command and the device address associated with the READ request by using control bus and address bus respectively. As soon as the device controller receives the request, it first sets ON a “device busy” indicator so that the system will not accept any further I/O request for the device. It then executes the request and stores the data for transfer in its local data register. As soon as it completes the request processing, it sets ON another indicator called “data ready” indicator. After issuing the READ request, the CPU continuously keeps checking the “data ready” indicator of the</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">device and waits until this indicator is set to ON. As soon as the CPU finds this indicator to be ON, it reads the data from the data register of the device controller into its own register. It then sends a data received acknowledgment signal to the device. On receiving this signal, the device controller resets its “device busy” and “data ready” indicators to OFF, which indicates that it is now ready to accept new I/O requests.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. <b>Interrupt. </b>In busy wait method, after issuing an I/O request, the CPU remains busy in checking for completion of the request until request processing is over. That is, from the time of issuing an I/O request until completion of the request, the CPU does not do anything else. This is inefficient use of CPU because I/O devices are about 1000 times slower than a CPU. Interrupt mechanism was devised to overcome this problem.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">In this method, after issuing the READ request to the I/O device, the CPU does not wait for the “data ready” indicator of the device to be set ON. Rather, it suspends the job that made the READ request and takes up another job that is ready for execution and starts executing this job while the device controller is busy processing the READ request. When the device controller completes processing the request and the data for transfer is ready in its local data register, it sends an <i>interrupt signal </i>to the CPU. When the CPU receives the interrupt signal, it knows that the data it requested is now ready. Hence, it suspends the job that it is currently executing, transfers the data from the data register of the device controller to its own register and resumes execution of the job that had made the I/O request.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">Interrupt mechanism is more difficult to implement than busy wait mechanism because it requires a mechanism to suspend a currently executing job and resume it later. How this is done will be discussed in a later chapter. Moreover, in case of multiple I/O devices, it also requires a mechanism to distinguish among the interrupt signals of different devices and to attend to them based on some priority rules because various devices can initiate interrupt signals independent of each other.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part121.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part123.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
