<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Hash Table</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part296.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part298.htm">Далее &gt;</a></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"><a href="#bookmark295" name="bookmark1526">Hash Table</a><a name="bookmark1622">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">A <i>hash table </i>is a table for storing data items, which uses a <i>hash function </i>to map data items into positions in the table. The hash function is applied on a data item itself or on a pre-specified field (called “key” field) of the data item (when the data item has more than one field) to map the data item into a specific position (called “index” or “bucket”) in the hash table. Hence, if “ <i>f</i>” is the hash function and “<i>ki</i>” is the value of the key of data item “<i>i</i>”, then data item “<i>i</i>” is mapped to index position “<i>pi</i>” of the hash table, where <i>pi = f(ki)</i>.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">A hash table enables quick storage and retrieval of data items. To search for a data item “<i>a</i>” with key “<i>ka</i>”, we compute <i>pa = f(ka) </i>and see if there is an element at position “<i>pa</i>” in the table. If so, we have found the data item, else the table has no data item with this key. If we have found the data item, we can retrieve or delete it from the table. If not found, we can add the data item to the table by inserting it at position “<i>pa</i>”.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Here we have assumed an ideal hash table, which is large enough to have a position for each key value. Although, this is possible for applications having small range of key values, there are many applications having so large range of key values that such a large hash table is practically infeasible. For such applications, we use a hash table whose size is smaller than the range of key values and a hash function that maps several different keys into the same position of the hash table. In this case, the most commonly used hash function is the one based on modulo operator, which has the form</p><p class="s16" style="padding-top: 3pt;padding-left: 8pt;text-indent: 0pt;text-align: center;">f(k) = k % S</p><p style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">where <i>k </i>is the key, <i>S </i>is the size of hash table (number of positions in it), and <i>% </i>is the modulo operator. The positions in the hash table are indexed from 0 to <i>S-1</i>.</p><p class="s46" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Figure 8.33<span class="s10"> </span><span class="p">shows a hash table with 8 positions (indexed 0 to 7), in which data items are mapped using the hash function</span></p><p class="s16" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;text-align: center;">f(k) = k % 8</p><p style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part297.htm#bookmark1623" class="s3">Figure </a><span class="s46">8.33</span><a href="part297.htm#bookmark1623" class="s23">(a) shows the original status of the hash table with three data items. </a><a href="part297.htm#bookmark1623" class="s3">Figure </a><span class="s46">8.33</span>(b) and 8.33(c) show the status after inserting data items with key values 76 and 95, respectively. Now suppose we wish to enter another data item with key value 33 into the hash table. Since, <i>f(33) = 33 % 8 = 1</i>, this data item should be entered in position having index value 1. However, this position is already having a data item. In such a situation, we say that a <i>collision </i>has occurred.</p><p class="s46" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part297.htm#bookmark1624" class="s23">Hash tables use some mechanism to handle collisions. One such mechanism is to use linked lists with the hash table. In this case, a position itself points to a linked list, which contains all the data items mapped to that position. </a><a href="part297.htm#bookmark1624" class="s3">Figure </a>8.34<span class="s10"> </span><span class="p">shows a hash table with the use of linked lists for handling collisions. In this hash table, each position has space for a pointer that points to a node of a linked list when the key of a data item maps to that position.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 75pt;text-indent: 0pt;text-align: left;"><span><img width="440" height="298" alt="image" src="Image_527.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1623">Figure 8.33. </a><span class="s21">A hash table with 8 positions and hash function f(k) = k % 8.</span></p><p style="padding-left: 59pt;text-indent: 0pt;text-align: left;"><span><img width="482" height="214" alt="image" src="Image_528.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1624">Figure 8.34. </a><span class="s21">A hash table with linked lists for handling collisions. It uses the hash function f(k) = k % 8.</span></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1625">To search for a data item with key “</a><i>k</i>”, we first compute <i>f(k) </i>for obtaining the table index, and then search the linked list that is pointed to by the pointer at this position. To insert a data item, we need to first ensure that the hash table does not contain a data item with the same key. For this, we need to search only the linked list pointed to by the pointer at the position to which the hash function maps the key of the data item. As a search precedes each insert, maintaining the linked lists in ascending order of the key values can make search and insert operations more efficient. We delete a data item from the hash table by first searching it in the manner mentioned above, and then deleting the corresponding node from the linked list to which it belongs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Operations for Handling Hash Tables</h4><p class="s46" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Figure 8.35<span class="s10"> </span><span class="p">lists the commonly supported operations for handling hash tables.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 57pt;text-indent: 0pt;text-align: left;"><span><img width="487" height="118" alt="image" src="Image_529.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1626">Figure 8.35. </a><span class="s21">Commonly supported operations for handling hash tables.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 7pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Uses of Hash Tables</h4><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">We often use hash tables for maintaining large tables (containing many data items) for those applications that need almost random access to any data item in the table. Such applications cannot rely on building a sorted table of data items and then using the binary search method for searching a data item because the performance of insert, delete, and search operations in this case are directly proportional to the number of data items. However, with the use of hash tables, performance of insert, delete and search operations are independent of the number of data items and depend largely on the hash function and the load on the hash table (lengths of associated linked lists).</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part296.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part298.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
