<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>One-way Authentication of Communicating Entities</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part547.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part549.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark546" name="bookmark2470">One-way Authentication of Communicating Entities</a><a name="bookmark2553">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">When an entity <i>A </i>wants to communicate with another entity <i>B, B </i>may like to verify the identity of <i>A </i>before allowing <i>A </i>to communicate with it. For example, a server may first verify the identity of any client that wants to communicate with it. Authentication protocols used commonly for one-way authentication of communicating entities are described here. The protocols are broadly of two categories - those based on symmetric cryptosystems and those based on asymmetric cryptosystems. Authentication protocols of both the categories use proof-by-knowledge principle.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Protocols Based on Symmetric Cryptosystems</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">In a symmetric cryptosystem, knowledge of shared key allows an entity to encrypt or decrypt arbitrary messages. Without such knowledge, an entity cannot encrypt or decrypt a message. Hence, in authentication protocols based on symmetric cryptosystems, the verifier verifies the identity of a claimant by checking if the claimant can encrypt a message correctly by using a key that the verifier believes is known only to an entity with the claimed identity (outside the entities used in the verification process).</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Let us assume that user <i>A </i>wants to communicate with user <i>B, </i>but <i>B </i>wants to authenticate <i>A </i>before starting communication. Also, assume that <i>K </i>is the key of a symmetric cryptosystem that users <i>A </i>and <i>B </i>share. The authentication protocol for this works as follows:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: left;">1. User <i>A </i>encrypts its identifier (<i>IDa</i>) by using key <i>K </i>to obtain a ciphertext <i>C1 = E </i>(<i>IDa, K</i>). It then sends a message <i>m1 </i>to user <i>B</i>, which contains <i>IDa </i>and <i>C1</i>.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: left;">2. On receiving <i>m1</i>, user <i>B </i>decrypts <i>C1 </i>by using key <i>K </i>and compares the obtained result with <i>IDa </i>of the message. If they match, user <i>B </i>accepts user <i>A</i>, otherwise rejects it.</p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">One major weakness of this protocol is its vulnerability to replays. That is, an intruder could masquerade as <i>A </i>by recording message <i>m1 </i>and replaying it later to <i>B. </i><a href="part548.htm#bookmark2555" class="s23">Security protocols counter replay attacks by using nonce or timestamp. A nonce-based challenge-response protocol that overcomes the problem of replay of messages works as follows (see </a><a href="part548.htm#bookmark2555" class="s3">Figure </a><span class="s46">15.2</span>):</p><p class="s16" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">1. User </span>A <span class="p">sends its identifier </span>(ID<span class="s35">a</span>) <span class="p">to user </span>B <span class="p">in plaintext form in a message </span>m<span class="s44">1</span>.</p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><span class="p">2. On receiving </span>m<span class="s44">1</span>, <span class="p">user </span>B <span class="p">generates a random number </span>N<span class="s35">r </span><span class="p">and sends </span>N<span class="s35">r </span><span class="p">to user </span>A <span class="p">in plaintext form in a message </span>m<span class="s44">2</span>.</p><p class="s16" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">3. On receiving </span>m<span class="s35">2</span>, <span class="p">user </span>A <span class="p">encrypts </span>N<span class="s35">r </span><span class="p">by using key </span>K <span class="p">to obtain a ciphertext </span>C<span class="s35">1 </span>= E (N<span class="s35">r</span>, K).</p><p class="s16" style="padding-left: 39pt;text-indent: 0pt;text-align: left;"><span class="p">It then sends </span>C<span class="s35">1 </span><span class="p">to </span>B <span class="p">in a message </span>m<span class="s35">1</span>.</p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;line-height: 117%;text-align: left;"><a name="bookmark2554"><span class="p">4. On receiving </span></a>m<span class="s44">3</span><span class="p">, user </span>B <span class="p">decrypts </span>C<span class="s44">1</span> <span class="p">by using key </span>K <span class="p">and compares the obtained result with the original value of </span>N<span class="s35">r</span>. <span class="p">If they are equal, user </span>B <span class="p">accepts user </span>A<span class="p">, otherwise rejects it.</span></p><p style="padding-top: 6pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">In this protocol, the freshness of <i>Nr </i>(whose value is different for each conversation) guarantees</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">that an intruder cannot masquerade as <i>A </i>by replaying a recording of an old authentication conversation between <i>A </i>and <i>B.</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 57pt;text-indent: 0pt;text-align: left;"><span><img width="489" height="130" alt="image" src="Image_804.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark2555">Figure 15.2. </a><span class="s21">One-way authentication protocol based on symmetric cryptosystem.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Although the above-described protocol functions correctly, it is impractical for a large-scale system because:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. The scheme requires each user to store secret keys of every other user it would ever want to authenticate. This may not be feasible practically in a large system having too many users and in which the number of users keeps changing frequently.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">2. Compromise of one user can potentially compromise the entire system.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Use of a centralized <i>authentication server (AS) </i><a href="part548.htm#bookmark2556" class="s23">can overcome these problems. AS is a trusted entity. All communicating users of the system share it. In this protocol, each user in the system shares a prearranged secret key with the AS. </a><a href="part548.htm#bookmark2556" class="s3">Figure </a><span class="s46">15.3</span> shows the authentication protocol (<i>Ka </i>and <i>Kb </i>are the secret keys of users <i>A </i>and <i>B, </i>respectively, that are shared with the AS).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 50pt;text-indent: 0pt;text-align: left;"><span><img width="506" height="215" alt="image" src="Image_805.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark2556">Figure 15.3. </a><span class="s21">One-way authentication protocol based on symmetric cryptosystem and use of a centralized authentication server.</span></p><p class="s16" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">1. User </span>A <span class="p">sends its identifier </span>(ID<span class="s35">a</span>) <span class="p">to user </span>B <span class="p">in plaintext form in a message </span>m<span class="s44">1</span>.</p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><span class="p">2. On receiving </span>m<span class="s44">1</span>, <span class="p">user </span>B <span class="p">generates a random number </span>N<span class="s35">r </span><span class="p">and sends </span>N<span class="s35">r </span><span class="p">to user </span>A <span class="p">in plaintext form in a message </span>m<span class="s44">2</span>.</p><p class="s16" style="padding-top: 7pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><a name="bookmark2557"><span class="p">3. On receiving </span></a>m<span class="s35">2</span>, <span class="p">user </span>A <span class="p">encrypts </span>N<span class="s35">r </span><span class="p">by using its secret key </span>K<span class="s35">a </span><span class="p">to obtain a ciphertext </span>C<span class="s35">1 </span><span class="p">=</span></p><p class="s16" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">E (N<span class="s35">r</span>, K<span class="s35">a</span>). <span class="p">It then sends </span>C<span class="s35">1 </span><span class="p">to </span>B <span class="p">in a message </span>m<span class="s35">3</span>.</p><p class="s16" style="padding-top: 3pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;"><span class="p">4. On receiving </span>m<span class="s44">3</span>, <span class="p">user </span>B <span class="p">encrypts the pair</span>(IDa, C<span class="s44">1</span><span class="p">) by using its secret key </span>K<span class="s35">b </span><span class="p">to generate a ciphertext </span>C<span class="s35">2 </span><span class="p">= </span>E ((ID<span class="s35">a</span>, C<span class="s35">1</span>)<span class="p">, </span>K<span class="s35">b</span>). <span class="p">It then sends </span>C<span class="s35">2 </span><span class="p">to AS in a message </span>m<span class="s35">4</span>.</p><p class="s16" style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;"><span class="p">5. On receiving </span>m<span class="s35">4</span><span class="p">, AS decrypts </span>C<span class="s35">2 </span><span class="p">with key </span>K<span class="s35">b </span><span class="p">and retrieves the pair </span>(ID<span class="s35">a</span>, C<span class="s35">1</span><span class="p">). It then extracts from its database the key </span>(K<span class="s35">a</span>) <span class="p">that corresponds to </span>ID<span class="s35">a </span><span class="p">and decrypts </span>C<span class="s44">1</span> <span class="p">with key </span>K<span class="s35">a </span><span class="p">and retrieves </span>N<span class="s35">r</span><span class="p">. Next, it encrypts </span>N<span class="s35">r </span><span class="p">by using key </span>K<span class="s35">b </span><span class="p">to generate a ciphertext </span>C<span class="s35">3 </span><span class="p">= </span>E (N<span class="s35">r</span>, K<span class="s35">b</span>). <span class="p">Finally, it sends </span>C<span class="s35">3 </span><span class="p">to </span>B <span class="p">in a message </span>m<span class="s35">5</span>.</p><p class="s16" style="padding-top: 5pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><span class="p">6. On receiving </span>m<span class="s44">5</span>, <span class="p">user </span>B <span class="p">decrypts it by using its secret key </span>K<span class="s35">b</span>, <span class="p">retrieves </span>N<span class="s35">r</span><span class="p">, and compares it with the original value of </span>N<span class="s35">r</span><span class="p">. If they are equal, user </span>B <span class="p">accepts user </span>A, <span class="p">otherwise rejects it.</span></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">As compared to the previous protocol, this protocol greatly alleviates key distribution and storage problems because now each user needs to keep only one key. Moreover, the system&#39;s security can be improved greatly by tightening the security only for the AS because the risk of compromise is mostly shifted to the AS. The centralized AS approach, however, suffers from the drawbacks of poor reliability and performance bottleneck of the single AS. Fresh authentications cannot take place if the node on which AS resides crashes, and the AS may get overloaded in a large system with too many users. These drawbacks can be overcome by using fully/partially distributed ASs in which the system uses multiple ASs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Protocols Based on Asymmetric Cryptosystems</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">An asymmetric cryptosystem publishes the public key of each user, and only a user (no one else) knows his/her secret key. Hence, in authentication protocols based on asymmetric cryptosystems, a verifier verifies the identity of a claimed user by checking if the claimant can encrypt a message correctly by using the secret key of the user.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Let us assume that user <i>A </i>wants to communicate with user <i>B, </i>but <i>B </i>wants to authenticate <i>A </i>before starting the communication. Also, assume that <i>P</i><span class="s35">a </span>and<i>S</i><span class="s35">a </span>are the public and secret keys of user <i>A, </i>and <i>P</i><span class="s35">b </span>and <i>S</i><span class="s35">b </span>are the public and secret keys of user <i>B. </i><a href="part548.htm#bookmark2558" class="s23">The authentication protocol for this works as follows (see </a><a href="part548.htm#bookmark2558" class="s3">Figure </a><span class="s46">15.4</span>):</p><p class="s16" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">1. User </span>A <span class="p">sends its identifier </span>(ID<span class="s35">a</span>) <span class="p">to user </span>B <span class="p">in plaintext form in a message </span>m<span class="s44">1</span>.</p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><span class="p">2. On receiving </span>m<span class="s44">1</span>, <span class="p">user </span>B <span class="p">generates a random number </span>N<span class="s35">r</span>, <span class="p">and sends </span>N<span class="s35">r </span><span class="p">to user </span>A <span class="p">in plaintext form in a message </span>m<span class="s44">2</span>.</p><p class="s16" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">3. On receiving </span>m<span class="s35">2</span>, <span class="p">user </span>A <span class="p">encrypts </span>N<span class="s35">r </span><span class="p">by using its secret key </span>S<span class="s35">a </span><span class="p">to obtain a ciphertext </span>C<span class="s35">1 </span><span class="p">=</span></p><p class="s16" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">E (N<span class="s35">r</span>, S<span class="s35">a</span>). <span class="p">It then sends </span>C<span class="s35">1 </span><span class="p">to </span>B <span class="p">in a message </span>m<span class="s35">3</span>.</p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><span class="p">4. On receiving </span>m<span class="s44">3</span>, <span class="p">user </span>B <span class="p">decrypts</span>C<span class="s44">1</span> <span class="p">by using the public key of user </span>A (P<span class="s35">a</span>), <span class="p">and compares the obtained result with original value of</span>N<span class="s35">r</span>. <span class="p">If they are equal, user </span>B <span class="p">accepts user </span>A<span class="p">, otherwise rejects it.</span></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"><span><img width="480" height="100" alt="image" src="Image_806.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark2558">Figure 15.4. </a><span class="s21">One-way authentication protocol based on asymmetric cryptosystem.</span></p><p class="s16" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><span class="p">As in the case of protocols based on symmetric cryptosystems, in this case also a system may use a protocol based on a centralized AS to greatly alleviate the key distribution and storage problems. In this protocol, AS maintains a database of all published public keys and each user in the system keeps a copy of the public key </span>(P<span class="s35">s</span>) <a href="part548.htm#bookmark2559" class="s23">of AS. The authentication protocol works as follows (see </a><a href="part548.htm#bookmark2559" class="s3">Figure </a><span class="s46">15.5</span><span class="p">):</span></p><p class="s16" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">1. User </span>A <span class="p">sends its identifier </span>(ID<span class="s35">a</span>) <span class="p">to user </span>B <span class="p">in plaintext form in a message </span>m<span class="s44">1</span>.</p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: left;"><span class="p">2. On receiving </span>m<span class="s44">1</span>, <span class="p">user </span>B <span class="p">generates a random number </span>N<span class="s35">r</span>, <span class="p">and sends </span>N<span class="s35">r </span><span class="p">to user </span>A <span class="p">in plaintext form in a message </span>m<span class="s44">2</span>.</p><p class="s16" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">3. On receiving </span>m<span class="s44">2</span>, <span class="p">user </span>A <span class="p">encrypts </span>N<span class="s35">r </span><span class="p">by using its secret key </span>Sa <span class="p">to obtain a ciphertext </span>C<span class="s44">1</span> <span class="p">=</span></p><p class="s16" style="padding-left: 39pt;text-indent: 0pt;text-align: left;">E (N<span class="s35">r</span>, S<span class="s35">a</span>). <span class="p">It then sends </span>C<span class="s35">1 </span><span class="p">to </span>B <span class="p">in a message </span>m<span class="s35">3</span>.</p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><span class="p">4. On receiving </span>m<span class="s35">3</span>, <span class="p">user </span>B <span class="p">sends the pair </span>(R<span class="s35">b</span>, ID<span class="s35">a</span>) <span class="p">to AS in plaintext form in a message </span>m<span class="s35">4</span>, <span class="p">where </span>R<span class="s35">b </span><span class="p">is a request code for requesting the public key of the user whose identifier is specified in the second element of the message.</span></p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><span class="p">5. On receiving </span>m<span class="s44">4</span>, <span class="p">AS extracts from its database the public key </span>(P<span class="s35">a</span>) <span class="p">of the user whose identifier is</span>ID<span class="s35">a</span>. <span class="p">It then encrypts the pair </span>(ID<span class="s35">a</span>, P<span class="s35">a</span>) <span class="p">by using its own secret key </span>S<span class="s35">s </span><span class="p">to generate a ciphertext </span>C<span class="s35">2 </span><span class="p">= </span>E ((ID<span class="s35">a</span>, P<span class="s35">a</span>), S<span class="s35">s</span>). <span class="p">Finally, it sends </span>C<span class="s35">2 </span><span class="p">to </span>B <span class="p">in a message </span>m<span class="s35">5</span>.</p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><span class="p">6. On receiving </span>m<span class="s44">5</span>, <span class="p">user </span>B <span class="p">decrypts</span>C<span class="s44">2</span> <span class="p">by using the public key of AS </span>(P<span class="s35">s</span>) <span class="p">and retrieves the pair </span>(ID<span class="s35">a</span>, P<span class="s35">a</span>). <span class="p">Now by using the key </span>P<span class="s35">a</span>, it <span class="p">decrypts </span>C<span class="s35">1 </span><span class="p">and compares the obtained result with original value of </span>N<span class="s35">r</span>. <span class="p">If they are equal, user </span>B <span class="p">accepts user </span>A<span class="p">, otherwise rejects it.</span></p><p style="padding-left: 90pt;text-indent: 0pt;text-align: left;"><span><img width="400" height="380" alt="image" src="Image_807.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 195pt;text-indent: -179pt;text-align: left;"><a name="bookmark2559">Figure 15.5. </a><span class="s21">One-way authentication protocol based on asymmetric cryptosystem and the use of a centralized authentication server.</span></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark2560">Notice that in this protocol each user needs to keep only one public key, the public key of AS. Also, notice that the above protocol assumes that the asymmetric cryptosystem is commutative. That is, the public and secret keys function in either order. Therefore, if an authentication system based on this protocol uses the public key for encryption, then it can use the secret key for decryption, whereas if it uses the secret key for encryption, then it can use the public key for decryption.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part547.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part549.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
