<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Process Management in Early Systems</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part348.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part350.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark347" name="bookmark1808">Process Management in Early Systems</a><a name="bookmark1869">&zwnj;</a><a name="bookmark1870">&zwnj;</a></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">In early computer systems, the process of executing a job was as follows:</p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">1. A programmer first wrote a program on paper.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. The programmer or a data entry operator then punched the program and its data on cards or paper tape.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. The programmer then submitted the deck of cards or the paper tape containing the program and data at the reception counter of a computer centre.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">4. An operator then loaded the cards deck or paper tape manually into the system from card reader or paper tape reader. The operator also loaded any other software resource (such as a language compiler), or carried out required settings of hardware devices for execution of the job. Before loading the job, the operator used front panel switches of the system to clear any data remaining in main memory from the previous job.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">5. The operator then carried out required settings of the appropriate switches in the front panel to run the job.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">6. Finally, the operator printed and submitted the result of execution of the job at the reception counter for the programmer to collect it later.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Every job went through the same process. The method was known as <i>manual loading mechanism </i>because the operator loaded the jobs one after another in the system manually. Notice that in this method, job-to-job transition was not automatic. Hence, a computer remained idle while an operator loaded and unloaded jobs and prepared the system for a new job. This caused enormous wastage of valuable computer time. To reduce this idle time, researchers later devised a mechanism (called <i>batch processing</i>) for automatic job-to-job transition. Batch processing ensured that after completing execution of a job, the system transferred control back to the operating system automatically. The operating system then performed housekeeping jobs (such as clearing any data remaining in memory from previous job), which were needed to load and run the next job. Hence, in a batch processing system, the process of executing jobs was as</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">follows:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: left;">1. Programmers prepared their programs and data on decks of cards or paper tapes, and submitted them at the reception counter of a computer centre.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: left;">2. An operator collected all the submitted programs periodically, batched them together, and then loaded them all at one time into the input device of the system.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3. The operator then gave a command to the system to start executing the batched jobs.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">4. The system then loaded the jobs automatically from the input device, and executed them one-by-one without any operator intervention. That is, the system read the first job from the input device, executed it, printed its result, and then repeated these steps for each subsequent job, until all jobs in the submitted batch of jobs were over.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">5. After the system completed execution of all jobs in the submitted batch, the operator separated and kept the printed output of each job at the reception counter for programmers to collect them later.</p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Batch processing mechanism helped in reducing idle time of a computer system because job-to- job transition did not require any operator intervention. Another major time saving made possible by batch processing was reduction in set-up time by operator by batching of similar jobs together. For example, by batching together all FORTRAN compilation jobs received, the system needs to load FORTRAN compiler once only for processing all these jobs.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1871">The obvious question is how a computer separates one job from another from a batch of jobs for automatic job-to-job transition. Moreover, how does the system know which compiler or what hardware devices a job needs for execution, when there is no operator intervention? To facilitate all these, researchers introduced the concept of </a><i>control statements </i>and <i>job control languages </i><a href="part349.htm#bookmark1872" class="s23">(JCLs) along with the concept of batch processing. Operating systems use control statements to identify a new job and to determine the resources needed by it during its execution. Users write control statements in a language known as job control language. Hence, each job has, besides its program and data, a set of instructions called JCL instructions, instructing the operating system on identity and requirements of the job. JCL statements specify things such as name of a job, its user&#39;s name with account number, its hardware and software resource requirements (I/O devices, language processor, software libraries, etc. required during its processing), etc. </a><a href="part349.htm#bookmark1872" class="s3">Figure </a><span class="s46">10.2</span> shows a sample deck of cards for compilation and execution of a COBOL program in a batch processing system.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Notice that a control card uses a special character or pattern in pre-decided column(s) of the card to distinguish itself from a data card or a program card. Several systems used dollar-sign character ($) in the first column on each control card, while IBM&#39;s JCL used slash marks (//) in the first two columns. Other systems used some other characters or codes. Basic idea in selection of these special characters or codes was that no program or data card should have these characters or code in the pre-decided column(s).</p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"><span><img width="480" height="287" alt="image" src="Image_608.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 109pt;text-indent: -89pt;text-align: left;"><a name="bookmark1872">Figure 10.2. </a><span class="s21">Illustrating use of job control statements and structure of a sample deck of cards submitted for processing in a batch processing system. JCL cards are shaded.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part348.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part350.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
