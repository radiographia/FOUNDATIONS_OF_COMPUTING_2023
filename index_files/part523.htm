<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Basic Compression Techniques</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part522.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part524.htm">Далее &gt;</a></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark521" name="bookmark2373">Basic Compression Techniques</a><a name="bookmark2424">&zwnj;</a><a name="bookmark2425">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Some basic compression techniques are described here. An actual compression technique is often a combination of one or more of these basic compression techniques.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Lossless Techniques</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The following two lossless compression techniques are commonly used:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Run-length coding. </b>This method replaces a repeated symbol in a string with the symbol and its number of occurrences. For example, it replaces “aaaabbcccccaaaaaababbbb” with “a4b2c5a6b1a1b4”.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. <b>Variable-length coding. </b>In general, coding schemes for a character set use a fixed number of bits per character. For example, BCD, EBCDIC, and ASCII coding schemes use a fixed number of bits per character. Statistical studies show that the frequency of occurrence (use) of different characters of a character set is different (for example, character Z occurs less frequently than character A in any English text). A variable-length coding scheme is based on this concept. It uses fewer bits to represent more frequently occurring characters than less frequently occurring ones. Obviously, it represents the most frequently occurring character with one bit only. Huffman coding is an example of this method. It is described here with an example.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Let us assume that the character set in this example consists of only six characters: A, B, C, D, E, and F. A conventional coding scheme that uses a fixed number of bits per character would require three bits per character (because 2<span class="s22">2 </span>&lt; 6 &lt; 2<span class="s22">3</span><a href="part523.htm#bookmark2426" class="s23">). Now suppose the relative frequency of occurrence of the characters in this character set is as shown in </a><a href="part523.htm#bookmark2426" class="s3">Figure </a><span class="s46">14.8</span>. The figure also shows a Huffman coding of these six characters, which minimizes the total number of bits for characters appearing with the frequency shown.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 160pt;text-indent: 0pt;text-align: left;"><span><img width="213" height="128" alt="image" src="Image_769.jpg"/></span></p><p class="s20" style="padding-top: 3pt;padding-left: 216pt;text-indent: -195pt;text-align: left;"><a name="bookmark2426">Figure 14.8. </a><span class="s21">An example of Huffman coding for a given character set with probability of occurrence of the characters.</span></p><p class="s46" style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part523.htm#bookmark2426" class="s23">Note that Huffman encoding scheme pays off only with uneven character distribution. For example, if all the characters in </a><a href="part523.htm#bookmark2426" class="s3">Figure </a>14.8<span class="s10"> </span><a href="part523.htm#bookmark2426" class="s23">occur equally often, mean number of bits per character would be 3.33. This is worse than a fixed-length coding scheme in which mean number of bits per character would be 3. For probabilities given in </a><a href="part523.htm#bookmark2426" class="s3">Figure </a>14.8<span class="p">, mean number of bits per character is 2.05.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Lossy Techniques</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The following two lossy compression techniques are commonly used:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Predictive encoding. </b>Generally, adjacent samples or frames are similar to each other in many types of multimedia objects (like digital audio or video). Predictive encoding method takes advantage of this fact and stores only the initial sample and difference values between every two adjacent samples for all samples in compressed form. Decompression of compressed data involves reproducing a sample from its previous sample and difference value between the two samples. Since the size of difference value between two samples is usually much smaller than the size of a sample itself, file size of compressed data is generally much smaller than the size of uncompressed data file. Note that the sample may be a pixel, line, audio sample, or video frame.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;"><a name="bookmark2427">2. </a><b>Transform encoding. </b>This method converts data from one domain to another domain, which is more convenient to compress. For example, conversion of data from time domain to frequency domain. DCT (Discrete Cosine Transform) encoding is the best example of this method. It is described here.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">DCT encoding transforms samples from time domain to frequency domain. Input data is fed as a two-dimensional block, typically with 8 x 8 pixels. DCT transforms an 8 x 8 block of pixel color values into an 8 x 8 matrix of spatial frequencies. It positions low frequencies (i.e., general information) near the upper left corner, and higher frequencies (i.e., sharp edges) near the lower right corner. It divides the coefficients of the output DCT matrix by the corresponding entries of an 8 x 8 quantization table (Q-table). Each entry of the Q-table describes the quality factor of the corresponding DCT output coefficient. Lower the quality factor, higher the magnitude of value. For example, for DCT compression, lower frequencies are more important than higher ones. Therefore, it uses a Q-table with smaller numbers near the upper-left corner and larger ones near the lower- right corner. Division of the DCT output matrix by the Q-table causes the lower-right corner portion of the resultant matrix to become mostly zeros. As a result, it discards the greater portion of high-frequency information. Modification of Q-table is one way to change the degree of compression. Entries in Q-table are based on eye-masking experiments and are essentially an approximation to the best estimate of levels that provide just-noticeable distortion in the image.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">DCT decoder performs the reverse process and converts the 64 coefficients back to pixel values. Since quantization is a lossy process, it may not exactly reproduce the original data.</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part522.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part524.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
