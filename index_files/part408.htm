<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>File Organizations</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part407.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part409.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark406" name="bookmark2004">File Organizations</a><a name="bookmark2043">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">File organization deals with physical organization of records of a file for convenience of their storage and retrieval. System designers choose to organize, access, and process records of various files in different ways, depending on application type and users&#39; needs. Three file organizations, which data processing applications use commonly are sequential, direct/random, and indexed sequential.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark2044">Selection of a particular file organization depends on application type. The best file organization for an application is one that meets the application&#39;s data access and processing requirements in the most effective and economical manner. Hence, an application designer must evaluate the strengths and weaknesses of each file organization, before making a choice of the file organization for his/her application.</a></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">File organization requires use of some <i>key field </i>in every record in a file. Key field value must be unique for each record of the file because duplications would cause serious problems. A payroll application often uses employee-code field as key field.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Sequential Files</h4><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A sequential file stores its records one after another in ascending/descending order of their key field values. A payroll application may organize the records of employee file sequentially by employee-code sequence. Sequential files use magnetic tape as principal storage medium.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A computer processes a sequential file in the order in which the file stores its records. That is, it first reads and processes the first record, then the second record, and so on. For instance, to locate a particular record in a sequential file, the computer reads each record in sequence, beginning from the first record, and compares its key field value with that of the desired record. The search ends when the desired key value matches with the key field value of the currently read record. Notice that with this processing mechanism, if an application has to process a single record only, on an average, it has to search about half the file to retrieve the record. Hence, sequential files are not suitable for applications that process only one or a few records at a time.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Sequential file organization is the most efficient and economical file organization for</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">applications in which we have to update a large number of file records at regularly scheduled intervals. That is, when <i>activity ratio </i>(ratio of total number of records in transaction file and total number of records in master file) is high. A batch processing application can ensure this. A batch processing application accumulates similar type of transactions in batches, then sorts these batches in sequence with respect to the key field, and then processes the entire batch of records in a single pass through the file. Applications such as payroll processing and monthly bill processing are examples of batch processing applications.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Advantages of Sequential Files</h4><p style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. They are simple to understand and use.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. They are easy to organize and maintain.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3. They need relatively inexpensive I/O media and devices for their storage and processing.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: left;">4. They are efficient and economical to use for applications in which activity ratio is high (the application processes most records during update runs).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Disadvantages of Sequential Files</h4><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. They are inefficient and uneconomical to use for applications in which activity ratio is low.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. Their use is limited to batch-processing environment because of the need to accumulate transactions in batches. Accumulating transactions in batches keeps activity ratio high during processing.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. Sequential processing precludes the possibility of up-to-the-minute data because of the need to accumulate transactions in batches before processing them.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">4. Sequential processing requires extra overhead of sorting the files before using them for processing. That is, the application must first sort both transaction and master files in the same sequence before processing.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">5. Sequential processing often leads to data redundancy problem, since a sequential processing application may store the same data in several files sequenced on different keys.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark2045">Direct Files</a></h4><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Many applications require up-to-the-minute timeliness of data. Users of such applications cannot afford to wait for accumulation of transactions in batches before processing them. They require processing of a transaction immediately whenever it occurs. Examples of such applications are airline or railway reservation systems, teller facility in banking applications, online encyclopedia, etc. Since these applications process only one transaction at a time, activity ratio is very low in these applications, making use of sequential files inefficient and uneconomical. <i>Direct/random file organization </i>is suitable for such an application because the application can directly locate any record by its key field value, without having to search through a sequence of other records. For example, when a passenger makes a reservation request for a train, the computer maintaining</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">and processing the reservation records directly accesses the record for the train and updates its seats position for specified journey date. Obviously, a direct/random file requires a direct access storage device for its storage to enable direct access of records. Direct/random files use magnetic/optical disk as the principal storage medium.</p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Obvious question that arises is how a direct file organizes its records physically so that applications can access any record directly, given its key field value. To enable this, direct file organization uses an address-generating function to convert a record key value into a storage address on the disk, which stores the file. The file stores each record at a location to which the address-generating function maps the record&#39;s key field value. This mechanism is known as<i>hashing </i>and the address-generating function is called <i>hashing algorithm</i>.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Although, a hashing algorithm generates a unique address for each record key value, but in practice, it sometimes maps the key values of two or more records to the same storage address. This problem is known as <i>collision</i>. There are many ways to handle a collision. One method is to use a pointer at the address generated by the hashing algorithm. This pointer points to a linked list of addresses containing physical addresses of all records whose key values map to the address generated by the hashing algorithm.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">To search a record, given its key value, the computer applies the hashing algorithm on the given key to generate its corresponding address. If it finds the record at the generated address, the search ends. Otherwise, the computer uses the pointer stored at the generated address to access the corresponding linked list. It accesses the addresses stored in the linked list elements and the corresponding records one-by-one, and compares the given key with the key of the accessed record. The search ends when it finds a record with matching key.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">If  required,  an  application  can  process  the  records  of  a  direct  file  sequentially  in ascending/descending sequence of key field value. However, if the application needs to process a large number of records sequentially (that is, if activity ratio is high), direct files prove to be inefficient as compared to sequential files, because the computer has to use a hashing algorithm and reposition the read/write head of disk for every record that the application processes.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Advantages of Direct Files</h4><p style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. Given the key, a direct file can quickly locate and retrieve any record directly.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. It does not require sorting of transactions in sequence before processing.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">3. It does not require accumulation of transactions in batches before processing them. An application can process a transaction whenever the transaction occurs.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">4. It can support interactive online applications, which provide up-to-the-minute information in response to inquiries from users.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">5. If required, an application can process direct file records sequentially.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Disadvantages of Direct Files</h4><p style="padding-top: 10pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">1. Direct files require relatively expensive hardware and software resources because they require a direct-access storage device (such as disk) for their storage.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><a name="bookmark2046">2. Due to address generation overhead involved, they are less efficient and less economical</a></p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">than sequential files for use in sequential applications with high activity ratio.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. They often require special security and access synchronization mechanisms because interactive online applications generally access online direct files simultaneously from multiple online stations.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Indexed Sequential Files</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">We are familiar with the concept of an index. For example, a display board at the entrance lobby of a large multistoried building displaying names and apartment numbers of occupants is an index, which helps visitors locate a person&#39;s apartment within the building. For instance, to find Dr. Sharma&#39;s apartment within the building, a visitor would look up his name on the display board (index) and read the corresponding floor number and apartment number. This idea of scanning a logically sequenced table is easier and quicker way of searching an apartment than searching door-to-door. Similarly, if a reader wishes to read the section on printers in this book, he/she would not begin on page 1 and read every page until he/she comes across this topic. Rather, the reader would search this topic in the table of contents at the beginning of the book (which serves as an index), or in the index at the end of the book, to locate the corresponding page number, and then turning to that page to begin reading.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part408.htm#bookmark2047" class="s23">Indexed sequential files use the same principle. As </a><a href="part408.htm#bookmark2047" class="s3">Figure </a><span class="s46">11.3</span> shows, indexed sequential file organization uses two files for every data file - <i>data file </i>(which contains records of the file), and <i>index file </i><a href="part408.htm#bookmark2047" class="s23">(which contains the index key and disk address of each record of the file). The data file can store the records in random sequence, but the index file stores the index keys in sorted sequence on index key value. With this arrangement, an application can use the file for both random and sequential processing. For processing a search request for a record, the computer first searches the smaller, more accessible index file to obtain the physical location of the record, and then accesses the corresponding record from the data file. For instance, to locate an employee&#39;s record (in the example of </a><a href="part408.htm#bookmark2047" class="s3">Figure </a><span class="s46">11.3</span>) whose employee-code is 0004, the computer first searches the index file for this employee-code key and obtains the corresponding address value 1002. It then accesses the record stored at address location 1002 in the data file.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 76pt;text-indent: 0pt;text-align: left;"><span><img width="435" height="144" alt="image" src="Image_655.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark2047">Figure 11.3. </a><span class="s21">Organization of an indexed sequential file.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">This technique of file management is known as <i>Indexed Sequential Access Method </i>(<i>ISAM</i>) and files of this type are called <i>ISAM </i>files.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Advantages of Indexed Sequential Files</h4><p style="padding-top: 10pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. Applications with high activity ratio can use index sequential files quite efficiently for</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">sequential processing.</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. Applications with low activity ratio can also use index sequential files quite efficiently for direct access processing.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Disadvantages of Indexed Sequential Files</h4><p style="padding-top: 10pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. They require relatively expensive hardware and software resources because they need a direct-access device (such as disk) for storage.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><a name="bookmark2048">2. They require more storage space than other types of files because of the need for index file.</a></p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. They are unsuitable for online applications requiring direct access to records. This is because direct access to records in index sequential files is slower as compared to that in direct files.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part407.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part409.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
