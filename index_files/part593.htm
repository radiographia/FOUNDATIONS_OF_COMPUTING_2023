<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Guidelines for Secure Systems Design</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part592.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part594.htm">Далее &gt;</a></p><p style="padding-top: 6pt;padding-bottom: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark591" name="bookmark2515">GUIDELINES FOR SECURE SYSTEMS DESIGN</a><a name="bookmark2665">&zwnj;</a><a name="bookmark2666">&zwnj;</a></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="624" height="1" alt="image" src="Image_846.png"/></span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Researchers working in the area of information system security have identified some design principles that designers of security systems should use as basic guidelines for designing secure systems. These design principles are as follows.</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Least privilege. </b>Principle of least privilege (also known as need-to-know principle) states that any process should be given only those access rights that enable it to access, at any time, what it needs to accomplish its function and nothing more and nothing less. That is, a security system must be flexible enough to allow the access rights of a process to grow and shrink with its changing access requirements. This principle serves to limit the damage when a system&#39;s security is broken. For example, if a system provides to an editor the right to access only the file that it has to edit, even if the editor has a Trojan horse, it will not be able to access other files of the user and hence cannot do much damage.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. <b>Fail-safe defaults. </b>A subject should acquire access rights by explicit permission only and the default should be no access. This principle requires that a system should base its access control decisions on why an object should be accessible to a subject rather than on why it should not be accessible.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. <b>Open design. </b>This principle requires that the design of a system&#39;s security mechanisms should not be secret, but should be public. It is a mistake on the part of a designer to assume that intruders will not know how the security mechanism of the system works.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">4. <b>Built into the system. </b>This principle requires that designers of a system should design its security components into the system right from the beginning, and should build the security components into the lowest layers of the system. That is, they should not treat security as an add-on feature because security problems cannot be resolved effectively by patching the penetration holes detected in an existing system.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">5. <b>Check for current authority. </b>This principle requires that a security system must check every access to every object using an access control database for authority. This is necessary to have immediate effect of revocation of previously given access rights. For instance, some file systems check for access permission only when a user opens a file, and they allow subsequent accesses to the file without any check. In these systems, a user can keep a file open for several days and continue to have access to its contents, even if the owner of the file changes the access permission and revokes the user&#39;s right to access its contents.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">6. <b>Easy granting and revocation of access rights. </b>For greater flexibility, a security system must allow granting/revocation of access rights for an object dynamically. It should be possible to restrict some of the rights and to grant to a user only those rights that are sufficient to accomplish its functions. On the other hand, a good security system should allow immediate revocation with the flexibility of selective and partial revocation. With <i>selective revocation </i>facility, it is possible to revoke access rights to an object only from a selected group of users rather than from all users who possess access rights for the object. Moreover, with <i>partial revocation </i>facility, the system can revoke only a subset of the rights granted to a user for an object instead of always revoking all its rights for the object.</p><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">7. <b>Never trust other parties. </b>For producing a secure system, designers must design the system components with the assumption that other parties (people or programs) are not trustworthy until they demonstrate to be trustworthy. For example, designers of client- server systems must always design clients and servers to view each other with mutual suspicion.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">8. <b>Always ensure freshness of messages. </b>To avoid security violations through replay of messages, a system that deals with messages must always ensure freshness of messages exchanged between two communicating entities.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">9. <b>Build firewalls. </b>To limit the damage in case a system&#39;s security is compromised, the system must have firewalls built into it. One way to meet this requirement is to allow only short-lived passwords and keys in the system. For example, a shared secret key used to build a logical communication channel between a client and a server should be short- lived, perhaps changed with every communication session between them.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;"><a name="bookmark2667">10. </a><b>Efficient. </b>A system&#39;s security mechanisms must execute efficiently and be simple to implement.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">11. <b>Convenient to use. </b>To be psychologically acceptable, a system&#39;s security mechanisms must be convenient to use. Otherwise, users are likely to bypass them or use them incorrectly.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">12. <b>Cost effective. </b>Often, there is a tradeoff between a system&#39;s security needs and its other goals, such as performance or ease of use. Therefore, while designing a system&#39;s security, it is important to come up with the right set of trade-offs that take into account the system&#39;s security needs and the cost of providing associated security features, in terms of both money and personnel experience.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part592.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part594.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
