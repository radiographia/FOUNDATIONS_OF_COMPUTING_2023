<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Time-sharing</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part353.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part355.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark352" name="bookmark1813">Time-sharing</a><a name="bookmark1891">&zwnj;</a></p><p class="s16" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Time-sharing <span class="p">is a mechanism to provide simultaneous interactive use of a computer system by many users in such a manner that all users feel that he/she is the sole user of the system. It uses multiprogramming with a special CPU scheduling algorithm to achieve this.</span></p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1892">A  time-sharing  system  has  many  (even  hundreds  of)  user  terminals  connected  to  it simultaneously. Using these terminals, multiple users can work on the system simultaneously. Multiprogramming feature allows multiple user programs to reside simultaneously in main memory, and special CPU scheduling algorithm allocates a short period of CPU time one-by-one to each user process (from the first one to the last one, and then again beginning from the first one). The short period during which a user process gets to use CPU is known as </a><i>time slice</i>, <i>time slot</i>, or <i>quantum</i><a href="part354.htm#bookmark1893" class="s23">, and is typically of the order of 10 to 100 milliseconds. Hence, when the operating system allocates the CPU to a user process, the process uses the CPU until its time slice expires (system&#39;s clock sends an interrupt signal to CPU after every time slice), or it needs to perform some I/O operation, or it completes its execution during this period. Notice that the operating system takes away the CPU from a running process when its allotted time slice expires. </a><a href="part354.htm#bookmark1893" class="s3">Figure </a><span class="s46">10.11</span> <a href="part350.htm#bookmark1878" class="s23">shows the process state diagram of a time-sharing system (compare it with the process state diagram of </a><a href="part350.htm#bookmark1878" class="s3">Figure </a><span class="s46">10.5</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 111pt;text-indent: 0pt;text-align: left;"><span><img width="344" height="151" alt="image" src="Image_617.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1893">Figure 10.11. </a><span class="s21">Process state diagram for a time-sharing system.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Now let us see how the CPU scheduling algorithm, mentioned above, gives an impression to each user that he/she is the sole user of the system. Let the time slice be 10 milliseconds and the processing speed of the system&#39;s CPU be 500 million instructions per second. Hence, the system executes 500 x 10<span class="s22">6 </span>x 10<span class="s22">-3 </span>x 10 = 5 x 10 <span class="s22">6 </span>= 5 million instructions in 10 milliseconds. This is large enough for substantial progress of a single user process. Let there be 100 user terminals and 100 simultaneous users using the system. If the operating system allocates 10 milliseconds to each user process one-by-one, a user process will get CPU&#39;s attention once in every 100 x 10 milliseconds = 1 second. As human reaction time is of the order of a few seconds, a user will not notice any delay in execution of his/her commands and will feel that he/she is the sole user of the system, whereas in reality, many users are sharing a single computer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Requirements of Time-sharing Systems</h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Time-sharing systems require the following additional hardware and software:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">1. A number of user terminals so that multiple users can use the system simultaneously in interactive mode.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. Relatively large memory to support multiprogramming.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3. Memory protection mechanism to prevent a job&#39;s instructions and data from other jobs in a</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">multiprogramming environment.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">4. Job status preservation mechanism to preserve a job&#39;s status information when the operating system takes away the CPU from it, and restores this information back, before it gives the CPU to the process again.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">5. A special CPU scheduling algorithm that allocates CPU for a short period one-by-one to each user process in a circular fashion.</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: justify;">6. An interrupt mechanism to send an interrupt signal to the CPU after every time slice.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Advantages of Time-sharing Systems</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Although, time-sharing systems are complex to design, they provide the following advantages to their users:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><a name="bookmark1894">1. </a><b>Reduce CPU idle time. </b>Thinking and typing speed of a user is much slower than processing speed of a computer. Hence, during interactive usage of a system, while a user is engaged in thinking or typing his/her input, a time-sharing system services many other users. Time-sharing systems, therefore, reduce CPU idle time and provide higher system throughput.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. <b>Provide advantages of quick response time. </b>The special CPU scheduling algorithm used in time-sharing systems ensures quick response time to all users, which helps improve interactive  programming  and  debugging  efficiency  of  programmers.  Multiple programmers can work simultaneously for writing, testing, and debugging their programs, or for trying out various approaches to solve a problem. The greatest benefit of such a system is that all simultaneous users of the system can detect errors, correct them, and continue with their work immediately. This is in contrast to a batch system in which users have to correct errors offline and then resubmit their jobs for another run. We often measure in hours the time delay between job submission and return of the output in a batch system.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">3. <b>Offer good computing facility to small users. </b>Small users can gain direct access to more sophisticated hardware and software than they could otherwise justify or afford. In time- sharing systems, they merely pay a fee for the resources they use, and are relieved of hardware, software, and personnel problems associated with acquiring and maintaining their own installation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part353.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part355.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
