<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Assembler</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part309.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part311.htm">Далее &gt;</a></p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark308" name="bookmark1675">Assembler</a><a name="bookmark1718">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Since a computer can directly execute only machine language programs, we must convert (translate) an assembly language program into its equivalent machine language program before it can be executed on the computer. A translator program called <i>assembler </i>does this translation. It is so called because in addition to translating an assembly language program into its equivalent machine language program, it also “assembles” the machine language program in main memory of the computer, and makes it ready for execution.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part310.htm#bookmark1719" class="s23">As </a><a href="part310.htm#bookmark1719" class="s3">Figure </a><span class="s46">9.2</span> shows, input to the assembler is an assembly language program (often referred to as <i>source program</i>), and its output is the equivalent machine language program (often referred to as <i>object program</i>). Since the assembler translates each assembly language instruction into an equivalent machine language instruction, there is a one-to-one correspondence between the assembly language instructions of a source program and the machine language instructions of its equivalent object program. Note that during the process of translation of a source program into its equivalent object program by the assembler, the source program is not under execution. The assembler only converts it into a form that the computer can execute.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 27pt;text-indent: 0pt;text-align: left;"><span><img width="568" height="98" alt="image" src="Image_567.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1719">Figure 9.2. </a><span class="s21">Illustrating the translation process of an assembler.</span></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Due to the additional translation process involved, the computer has to spend more time in getting the desired result from an assembly language program as compared to a machine language program. However, assembly language programming saves so much time and effort of a programmer that the extra time and effort spent by the computer is worth it. Translation is a one-time process that requires relatively small time. Once the system obtains the object code, it can save it and subsequently execute it as many times as required.</p><p class="s46" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part310.htm#bookmark1720" class="s23">An example can best illustrate the process. Let us assume that a computer uses the mnemonics given in </a><a href="part310.htm#bookmark1720" class="s3">Figure </a>9.3<span class="s10"> </span><span class="p">for the operation codes mentioned against each. For simplicity, out of more than hundred operation codes available in the instruction set of a computer, we have considered here only five for writing our example program.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"><span><img width="478" height="166" alt="image" src="Image_568.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1720">Figure 9.3. </a><span class="s21">A subset of the set of instructions supported by a computer.</span></p><p class="s46" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part310.htm#bookmark1721" class="s3">Figure </a>9.4<span class="s10"> </span><span class="p">shows a simple assembly language program for adding two numbers and storing the result. To get an idea of how the assembler converts this program into an equivalent machine language program, let us follow its instructions one-by-one. Notice that the first five instructions of the program are pseudo-instructions for telling the assembler what to do. They are not part of the main program to add the two numbers.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 62pt;text-indent: 0pt;text-align: left;"><span><img width="474" height="186" alt="image" src="Image_569.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1721">Figure 9.4. </a><span class="s21">A sample assembly language program for adding two numbers and storing the result.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1722">The first instruction of the assembly language program tells the assembler that the instructions for the main program (to add two numbers) should start at memory location 0000. Based on this directive, the assembler loads the first instruction of the main program (which happens to be CLA FRST in this example) at memory location 0000. It loads each subsequent instruction in the following memory location (that is, ADD SCND at location 0001, STA ANSR at location 0002, and HLT at location 0003).</a></p><p class="s46" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part310.htm#bookmark1723" class="s23">The second instruction of the assembly language program tells the assembler that the data of the program should start at memory location 1000. The next three instructions tell the assembler to set aside addresses for data items FRST, SCND, and ANSR. Based on these four directives, the assembler sets up a mapping table somewhere in the computer memory that looks somewhat like the one in </a><a href="part310.htm#bookmark1723" class="s3">Figure </a>9.5<span class="p">. That is, the assembler picks up the first free address in the data area of the program, which is location 1000 and calls it FRST. It picks up the next free address in the data area, which is location 1001, and calls it SCND. Finally, it picks up the next free address in the data area, which is location 1002, and calls it ANSR.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 175pt;text-indent: 0pt;text-align: left;"><span><img width="171" height="132" alt="image" src="Image_570.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 10pt;text-indent: 0pt;text-align: center;"><a name="bookmark1723">Figure 9.5. </a><a href="part310.htm#bookmark1721" class="s42">Mapping table set up by the assembler for the data items of the assembly language program of </a><a href="part310.htm#bookmark1721" class="s37">Figure</a><a href="part310.htm#bookmark1721" class="s43"> </a><a href="part310.htm#bookmark1721" class="s37">9.4</a><a href="part310.htm#bookmark1721" class="s42">.</a></p><p class="s46" style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part310.htm#bookmark1720" class="s23">The next instruction of the assembly language program is CLA FRST, which the assembler translates into 10 1000, by translating CLA into 10 as in </a><a href="part310.htm#bookmark1720" class="s3">Figure </a>9.3<a href="part310.htm#bookmark1723" class="s23">, and FRST into 1000 as in </a><a href="part310.htm#bookmark1723" class="s3">Figure </a>9.5<span class="p">. Similarly, the assembler translates the instructions ADD SCND into 14 1001, STA</span></p><p class="s46" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="part311.htm#bookmark1726" class="s23">ANSR into 30 1002, and HLT into 00, thus, providing the resulting machine language program of </a>Figure 9.6<span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part309.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part311.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
