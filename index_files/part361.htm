<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Paging</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part360.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part362.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark359" name="bookmark1820">Paging</a><a name="bookmark1916">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Operating systems often use memory compaction mechanism to solve external fragmentation problem. However, memory compaction is an expensive operation requiring CPU time for copying of memory contents from one memory location to another to make scattered free space contiguous. <i>Paging </i>is another mechanism that operating systems use to solve external fragmentation problem. Operating system designers often consider it better than memory compaction mechanism because it solves the problem of external fragmentation without the need to make scattered free space contiguous. Rather it allows a process&#39;s memory to be noncontiguous, and allocates physical memory to a process from wherever free memory blocks are available. Because of its advantage over memory compaction mechanism, many modern operating systems use paging mechanism (in its various forms). This mechanism is explained here.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1917">In this mechanism, the operating system partitions the physical memory of a computer system into fixed-sized blocks called </a><i>page frames</i>. The operating system also partitions the total memory requirement of a process (including its instructions and data) into blocks of the same size called <i>pages</i>. Page sizes are typically of the order of 1 Kilobytes to 1 Megabytes and vary from one system to another. Now when the operating system selects a process for loading it into the memory, it loads its pages into the free page frames, wherever they are available. The operating system maintains a mapping table (called <i>page table</i><a href="part361.htm#bookmark1918" class="s23">) to keep track of which page of the process is loaded into which page frame of the memory. </a><a href="part361.htm#bookmark1918" class="s3">Figure </a><span class="s46">10.19</span> shows an example to illustrate this.</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Notice from the figure that the operating system need not allocate contiguous page frames to the pages of the process.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">To ensure correct memory addressing in a system that uses paging mechanism, the memory addressing mechanism divides every memory address into two parts consisting of a page number and a page offset. To access a memory location, the operating system uses the page table to obtain the corresponding page frame number from the page number, and adds the page offset to the base address of the page frame number to define the physical memory address of the memory location.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 63pt;text-indent: 0pt;text-align: left;"><span><img width="471" height="459" alt="image" src="Image_626.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1918">Figure 10.19. </a><span class="s21">An example to illustrate paging mechanism.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Notice that there is no external fragmentation problem in a system that uses paging mechanism because the operating system can allocate free page frames to a process from anywhere in the memory (need not be contiguous). However, paging mechanism leads to some unutilized memory space due to internal fragmentation because the unit of memory allocation is a page frame. If memory requirements of a process do not happen to fall on page boundaries, the last page frame allocated to the process will not be completely full. For example, if an operating system uses page size of 2048 bytes, and a process&#39;s memory requirement is 23,548 bytes, the process will need 11 pages plus 1020 bytes. As the unit of memory allocation is a page frame, operating system will allocate 12 page frames to the process, resulting in an internal fragmentation of 2048 - 1020 = 1028 bytes. On an average, in systems that use paging</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1919">mechanism, internal fragmentation leads to wastage of one-half page per process. Hence, the larger the page size, the larger is memory wastage due to internal fragmentation. This suggests the use of small page sizes. However, the smaller the page size, the larger is the size of page tables and the overhead involved in maintaining them. Hence, operating system designers must balance these two factors while deciding a suitable page size.</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part360.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part362.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
