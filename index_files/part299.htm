<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Binary Tree</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part298.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part300.htm">Далее &gt;</a></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;"><a href="#bookmark297" name="bookmark1528">Binary Tree</a><a name="bookmark1632">&zwnj;</a></p><p style="padding-top: 4pt;padding-left: 2pt;text-indent: 0pt;text-align: center;">A <i>binary tree </i>is a special type of tree in which the out-degree of any node is less than or equal to</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">two (zero, one, or two). Hence, a node can have maximum two subtrees, which are called <i>left subtree </i>and <i>right subtree </i><a href="part299.htm#bookmark1633" class="s23">of the node. If a node&#39;s out-degree is zero, it is a leaf node, which has neither left subtree nor right subtree. If its out-degree is one, it has either left subtree or right subtree. If its out-degree is two, it has both left and right subtrees. </a><a href="part299.htm#bookmark1633" class="s3">Figure </a><span class="s46">8.38</span> shows examples of such binary trees.</p><p class="s46" style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part299.htm#bookmark1633" class="s23">Linked representation is the most popular way to represent a binary tree. In this representation, each node has three fields - a data field, a “LeftChild” pointer field that points to the left child of the node, and a “RightChild” pointer field that points to the right child of the node. If a node has no left child or right child, the corresponding pointer(s) is set to zero (NULL). Additionally, it uses a pointer “Root” to keep track of the root of the binary tree. We can access all nodes of a binary tree by starting with the “Root” pointer and following “LeftChild” and “RightChild” pointers of the </a><a href="part299.htm#bookmark1634" class="s23">nodes. </a><a href="part299.htm#bookmark1634" class="s3">Figure </a>8.39<a href="part299.htm#bookmark1633" class="s24"> </a><a href="part299.htm#bookmark1633" class="s23">shows the linked representation of the binary tree of </a><a href="part299.htm#bookmark1633" class="s3">Figure</a><a href="part299.htm#bookmark1633" class="s24"> </a><a href="part299.htm#bookmark1633" class="s3">8.38</a><a href="part299.htm#bookmark1633" class="s23">(g).</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 45pt;text-indent: 0pt;text-align: left;"><span><img width="518" height="508" alt="image" src="Image_532.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1633">Figure 8.38. </a><span class="s21">A few examples of binary trees.</span></p><p style="padding-left: 166pt;text-indent: 0pt;text-align: left;"><span><img width="197" height="131" alt="image" src="Image_533.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1634">Figure 8.39. </a><a href="part299.htm#bookmark1633" class="s42">Linked representation of the binary tree of </a><span style=" color: #0000ED; font-family:&quot;Times New Roman&quot;, serif; font-style: italic; font-weight: normal; text-decoration: underline; font-size: 10pt;">Figure 8.38</span><span class="s21">(g).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1635">Properties of Binary Trees</a></h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">By their very nature, binary trees have the following properties:</p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. A binary tree with <i>n </i>nodes (<i>n &gt; 0</i>) has exactly <i>n-1 </i>branches.</p><p class="s16" style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">2. A binary tree of height </span>h <span class="p">(</span>h = 0<span class="p">) has at least </span>h <span class="p">and at most </span>2<span class="s31">h</span>-1 <span class="p">nodes.</span></p><p style="padding-top: 5pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3. The height of a binary tree having <i>n </i>nodes (<i>n = 0</i>) is at most <i>n </i>and at least +<i>log2 (n+1 )</i><span class="s40">+</span><span class="s41">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Binary Tree Traversal</h4><p class="s16" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Traversing <span class="p">a tree means visiting all its nodes in a defined order and listing (or processing) the data elements of the nodes in the sequence in which the process visits the nodes. The three common methods to traverse a binary tree are preorder, inorder and postorder traversal. They are described here.</span></p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. <b>Preorder. </b><a href="part299.htm#bookmark1636" class="s23">In this method, the process visits each node first, followed by its left subtree and then its right subtree. For example, if we perform preorder traversal of the binary tree of </a><a href="part299.htm#bookmark1636" class="s3">Figure </a><span class="s46">8.40</span>, we visit/process the root node (<i>+</i>) first, followed by its left subtree and then its right subtree. To traverse the left subtree, we visit/process its root node (<i>*</i>) first, followed by the only node in its left subtree (<i>a</i>) and then the only node in its right subtree</p><p style="padding-left: 38pt;text-indent: 0pt;text-align: justify;">(<i>b</i>). Since we have visited/processed all the nodes in the left subtree of the root node, we are now ready to process the right subtree of the root node ( <i>+</i>). Following the rules of preorder traversal, we visit/process the nodes in the right subtree in the order /, <i>c</i>, <i>d</i>. This completes the traversal resulting in the sequence <i>+*ab/cd </i><a href="part299.htm#bookmark1636" class="s23">of the data elements of the nodes (see </a><a href="part299.htm#bookmark1636" class="s3">Figure </a><span class="s46">8.40</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 80pt;text-indent: 0pt;text-align: left;"><span><img width="470" height="114" alt="image" src="Image_534.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 106pt;text-indent: 0pt;text-align: left;"><a name="bookmark1636">Figure 8.40. </a><span class="s21">Preorder, inorder and postorder traversals of a binary tree.</span></p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. <b>Inorder. </b><a href="part299.htm#bookmark1636" class="s23">In this method, for each node, the process first visits/processes the node&#39;s left subtree, followed by the node itself, and then its right subtree. For example, if we perform inorder traversal of the binary tree of </a><a href="part299.htm#bookmark1636" class="s3">Figure </a><span class="s46">8.40</span>, since we have to first visit/process the</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">left subtree of root node (<i>+</i>), we trace from the root to the far-left leaf node (<i>a</i>) before visiting/processing any other node. After visiting/processing node &#39; <i>a</i>&#39;, we visit/process its parent node ‘*’, followed by its right subtree node ‘<i>b</i>’. This completes the traversal of the left subtree of root node (<i>+</i>). Hence, we now visit/process the root node (<i>+</i>), followed by its right subtree. Following the rules of inorder traversal, we visit/process the nodes in the right subtree in the order <i>c</i>, <i>/</i>, <i>d</i>. This completes the traversal resulting in the sequence <i>a*b+c/d </i><a href="part299.htm#bookmark1636" class="s23">of the data elements of the nodes (see </a><a href="part299.htm#bookmark1636" class="s3">Figure </a><span class="s46">8.40</span>).</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">3. <b>Postorder. </b><a href="part299.htm#bookmark1636" class="s23">In this method, for each node, the process first visits/processes the node&#39;s left subtree, followed by its right subtree, and then the node itself. For example, if we perform postorder traversal of the binary tree of </a><a href="part299.htm#bookmark1636" class="s3">Figure </a><span class="s46">8.40</span>, since we have to first traverse the left subtree of root node (+), we trace from the root to the far-left leaf node (<i>a</i>) before visiting/processing any other node. After visiting/processing node ‘<i>a</i>’, we visit/process the right subtree of its parent node ‘*’, which happens to be a single node (<i>b</i>). We then visit/process the parent node ‘*’. This completes the traversal of the left subtree of the root node (+). Hence, we now traverse the right subtree of root node (+). Following the rules of postorder traversal, we visit/process the nodes in the right subtree in the order <i>c</i>, <i>d</i>, <i>/</i>. Finally, we visit/process the root node (+) itself. This completes the traversal resulting in the sequence <i>ab*cd/+ </i><a href="part299.htm#bookmark1636" class="s23">of the data elements of the nodes (see </a><a href="part299.htm#bookmark1636" class="s3">Figure </a><span class="s46">8.40</span>).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark1637">Operations for Handling Binary Tree</a></h4><p class="s46" style="padding-top: 5pt;text-indent: 0pt;text-align: right;">Figure 8.41<span class="s10"> </span><span class="p">lists the commonly supported operations for handling binary trees.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 90pt;text-indent: 0pt;text-align: left;"><span><img width="399" height="207" alt="image" src="Image_535.jpg"/></span></p><p class="s20" style="padding-top: 8pt;text-indent: 0pt;text-align: right;"><a name="bookmark1638">Figure 8.41. </a><span class="s21">Commonly supported operations for handling binary trees.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 7pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Uses of Binary Trees</h4><p class="s46" style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part299.htm#bookmark1636" class="s23">We frequently use binary trees in computer science because of the interesting relationship between binary trees and binary number system. As </a><a href="part299.htm#bookmark1636" class="s3">Figure </a>8.40<span class="s10"> </span><span class="p">shows, we also use them for representation of algebraic expressions involving binary operators (such as +, -, *, /). We will now see how to use binary trees to implement binary search trees and binary heaps.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part298.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part300.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
