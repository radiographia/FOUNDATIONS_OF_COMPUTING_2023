<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Points to Remember</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part302.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part304.htm">Далее &gt;</a></p><p style="padding-left: 8pt;text-indent: 0pt;text-align: center;"><a href="#bookmark301" name="bookmark1532">Points to Remember</a><a name="bookmark1668">&zwnj;</a></p><p style="padding-top: 10pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. To ensure that the instructions of a program are appropriate for the problem at hand and in the correct sequence, we must plan the program before writing it.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. The term <i>algorithm </i>refers to the logic of a program. It is a step-by-step description of how to arrive at a solution to a given problem.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">3. Factors often used to judge the quality of an algorithm are the time required to execute the corresponding program on a given computer, memory space required to execute it, accuracy of results produced by it, and its capability to handle a range of input data instead of a single input data (often referred to as <i>generality property</i>).</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">4. An algorithm represented in the form of a programming language is a <i>program</i>. Hence, any program is an algorithm, but the reverse is not true.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">5. Programmers often use flowcharts, decision tables, and pseudocodes for representing algorithms for their programs before coding them in programming languages.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">6. A <i>flowchart </i>is a pictorial representation of an algorithm. Programmers often use it as a program-planning tool for visually organizing a sequence of steps necessary to solve a problem using a computer.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">7. We use <i>decision tables </i>to define the word statement of a problem in a tabular form. They define complex program logic by charting what decisions or actions a computer is to take because of input data.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">8. <i>Pseudocode </i>is a program-planning tool that allows programmers to plan program logic by writing program instructions in a natural language, such as English.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">9. <i>Structured Programming </i>is a more scientific approach to solving a programming problem by using only three basic logic (control) structures namely, sequence logic, selection logic, and iteration (or looping) logic.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">10. Structured programming helps in producing programs that are easy to understand and maintain. It also helps in reducing program errors and the time spent in program testing.</p><p style="padding-top: 4pt;padding-left: 17pt;text-indent: 0pt;text-align: justify;">11. We use <i>sequence logic </i>for performing instructions one after another in sequence.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">12. We use <i>selection logic </i>for selecting a path out of two or more paths in program logic. It uses three control structures called IF…THEN, IF…THEN…ELSE, and CASE.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">13. We use <i>iteration </i>(or <i>looping</i>) <i>logic </i>for producing loops in program logic when we need to execute one or more instructions several times depending on some condition. It uses two control structures called DO…WHILE and REPEAT…UNTIL.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">14. <i>Data structures </i>define ways of organizing and storing different data types used in an algorithm.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">15. Data structures are of two types - primitive and composite. <i>Primitive data structures </i>are basic data types defined in a programming language, while <i>composite data structures </i>are composed using primitive data structures.</p><p style="padding-top: 3pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">16. An <i>array </i>is a group of data elements in which we identify an individual element by its position in the group, relative to the first element. Hence, we access an individual element by indexing.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">17. A <i>linked list </i>consists of a set of nodes linked together. Each node has two basic fields - data field and pointer field. The data field contains the data, while the pointer field links the node to another node belonging to the same linked list. In addition to the nodes, a linked list has a pointer called “head”, which points to the first node of the linked list. We use it to keep track of the list.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">18. A <i>stack </i>represents a pile of data items stacked one on top of another. We add/remove a data item from the top of the pile only. We also refer to it as <i>last-in-first-out (LIFO) </i>data structure.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">19. A <i>queue </i>represents a container of data items, which is open from both sides and in which we can add a data item at one end only (called “rear” end) and remove from the other end only (called “front” end). We also refer to it as <i>first-in-first-out </i>( <i>FIFO</i>) data structure.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">20. A <i>hash table </i>is a table for storing data items, which uses a <i>hash function </i>to map data items into positions in the table. If “<i>f</i>” is the hash function and “<i>ki</i>” is the value of the key of data item “<i>i</i>”, then data item “<i>i</i>” is mapped to index position “<i>pi</i>” of the hash table, where <i>pi = f(ki)</i>.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">21. A <i>tree </i>consists of a finite set of elements (called <i>nodes</i>) that are connected by a finite set of directed lines (called <i>branches</i>). A non-empty tree (which has at lease one node) has a node with in-degree equal to zero. This node is called the <i>root </i>of the tree. All other nodes have in-degree equal to one. The out-degree of any node (including the root) can be zero, one, or more.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">22. A <i>binary tree </i>is a special type of tree in which the out-degree of any node is less than or equal to two (zero, one, or two). Hence, a node can have maximum two subtrees, which are called <i>left subtree </i>and <i>right subtree </i>of the node.</p><p style="padding-top: 4pt;padding-left: 17pt;text-indent: 0pt;text-align: justify;">23. A <i>binary search tree </i>is a binary tree with the following properties:</p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="6" alt="image" src="Image_556.png"/></span></p><p style="padding-top: 8pt;padding-left: 69pt;text-indent: 0pt;text-align: left;">The data element of each node has a key field and no two nodes have the same key value (all keys are distinct).</p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="6" alt="image" src="Image_557.png"/></span></p><p style="padding-top: 4pt;padding-left: 69pt;text-indent: 0pt;text-align: left;">The keys of all nodes in the left subtree of the root have values less than the key in the root.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="6" alt="image" src="Image_558.png"/></span></p><p style="padding-top: 4pt;padding-left: 69pt;text-indent: 0pt;text-align: left;">The keys of all nodes in the right subtree of the root have values greater than the key in the root.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="6" height="6" alt="image" src="Image_559.png"/></span></p><p style="padding-top: 3pt;padding-left: 69pt;text-indent: 0pt;text-align: left;">Each subtree is itself a binary search tree.</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">24. A <i>graph </i>is a collection of <i>nodes </i>(also called <i>vertices</i>) and <i>edges </i>(also called <i>lines</i>). Each edge (<i>i, j</i>) joins two nodes <i>i </i>and <i>j</i>. If all the edges of a graph are directed edges, then the graph is called a <i>digraph</i>. When we assign weights to the edges of a graph/digraph, the resulting graph/digraph is called a <i>weighted graph/digraph</i>.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -21pt;text-align: justify;">25. A <i>heap </i>is a complete binary tree in which the value of each node is greater (less) than or equal to those of its children (if any). If the value of each node in a heap is greater than or equal to those of its children (if any), then the heap is called a <i>max heap</i>. On the other hand, if the value of each node in a heap is less than or equal to those of its children (if</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">any), then the heap is called a <i>min heap</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part302.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part304.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
