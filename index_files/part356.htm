<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Deadlock</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part355.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part357.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="#bookmark354" name="bookmark1815">Deadlock</a><a name="bookmark1900">&zwnj;</a><a name="bookmark1901">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">There are several resources in a system for which the resource allocation policy must ensure exclusive access by a process. For example, a process needs exclusive access to a printer until it finishes using the printer because simultaneous use of the printer by two or more processes will lead to garbled printed output. Since a system consists of a finite number of units of each resource type (for example, three printers, six tape drives, four disk drives, two CPUs, etc.), multiple concurrent processes have to compete to use a resource. In this situation, a process goes through the following sequence of events to use a resource:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Request. </b>The process first makes a request for the resource. If the resource is not available, possibly because another process is using it, the requesting process must wait until the operating system allocates the resource to it.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. <b>Allocate. </b>The operating system allocates the resource to the requesting process as soon as possible. It maintains a table to record which resources are free and which resources are allocated (and to which process). If the requested resource is currently allocated to another process, the operating system adds the requesting process to a queue of processes waiting for this resource. Once the system allocates the resource to the requesting process, that process can exclusively use the resource.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. <b>Release. </b>After the process finishes using the resource, it releases the resource. The operating system updates the table records at the time of allocation and release to reflect the status of availability of resources.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">The request and release of resources are system calls, such as<i>request </i>and <i>release </i>for devices, <i>open </i>and <i>close </i>for files, and <i>allocate </i>and <i>free </i>for memory space. Notice that out of the three operations, <i>allocate </i>is the only one that the operating system can control. The other two are not in operating system&#39;s control because a process initiates them (not the operating system).</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">With the pattern of request, allocation, and release of resources mentioned above, if the total request made by multiple concurrent processes for resources of a certain type exceeds the number available, the operating system must have a strategy to order the assignment of resources in time. The strategy should not cause a deadlock situation in which competing processes prevent their mutual progress even though no single one requests more resources than are available. It may happen that some of the processes that entered the waiting state (because the requested resources were not available at the time of request) will never again change state, because other waiting processes are holding the resources they have requested. This situation is called<i>deadlock</i>, and the processes involved are said to be <i>deadlocked</i>. Hence, deadlock is the state of permanent blocking of a set of processes each of which is waiting for an event that only another process in the set can cause. All the processes in the set block permanently, because all the processes are waiting and hence none of them will ever cause any of the events that could wake up any of the other members of the set.</p><p class="s46" style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part356.htm#bookmark1902" class="s23">An example can best explain a deadlock situation (see </a>Figure 10.14<span class="p">). Suppose that a system has</span></p><p class="s16" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;line-height: 109%;text-align: justify;"><span class="p">two tape drives </span>T<span class="s44">1</span> <span class="p">and </span>T<span class="s44">2</span> <a href="part356.htm#bookmark1902" class="s23">and the resource allocation strategy is such that the operating system immediately allocates a requested resource to the requesting process, if the resource is free</a><span class="p">. Also, suppose that two concurrent processes </span>P<span class="s44">1</span> <span class="p">and </span>P<span class="s44">2</span> <a href="part356.htm#bookmark1902" class="s23">make requests for the tape drives in the</a></p><p style="padding-top: 1pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">following order:</p><p class="s16" style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">1. </span>P<span class="s44">1</span> <span class="p">requests for one tape drive and the operating system allocates </span>T <span class="s44">1</span> <span class="p">to it.</span></p><p class="s16" style="padding-top: 6pt;padding-left: 23pt;text-indent: 0pt;text-align: left;"><span class="p">2. </span>P<span class="s44">2</span> <span class="p">requests for one tape drive and the operating system allocates </span>T <span class="s44">2</span> <span class="p">to it.</span></p><p class="s16" style="padding-top: 6pt;padding-left: 39pt;text-indent: -15pt;line-height: 117%;text-align: left;"><span class="p">3. </span>P<span class="s44">1</span> <a href="part356.htm#bookmark1902" class="s23">requests for one more tape drive and enters a waiting state because no tape drive </a><span class="p">is presently available.</span></p><p class="s16" style="padding-top: 1pt;padding-left: 39pt;text-indent: -15pt;line-height: 117%;text-align: left;"><span class="p">4. </span>P<span class="s44">2</span> <a href="part356.htm#bookmark1902" class="s23">requests for one more tape drive and it enters a waiting state because no tape drive </a><span class="p">is presently available.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 161pt;text-indent: 0pt;text-align: left;"><span><img width="210" height="134" alt="image" src="Image_620.jpg"/></span></p><p class="s21" style="padding-top: 9pt;padding-left: 21pt;text-indent: 0pt;text-align: left;"><a name="bookmark1902"><b>Figure 10.14. </b></a>An example of a deadlock situation involving processes P <span class="s45">1</span> and P<span class="s45">2</span><a href="part356.htm#bookmark1902" class="s42"> and resources T1 and T2.</a></p><p class="s16" style="padding-top: 8pt;padding-left: 6pt;text-indent: 0pt;line-height: 16pt;text-align: justify;"><a name="bookmark1903"><span class="p">From now on, </span></a>P<span class="s44">1</span> <span class="p">and </span>P<span class="s44">2</span> <span class="p">wait for each other indefinitely, since </span>P<span class="s44">1</span> <span class="p">will not release </span>T<span class="s44">1</span> <a href="part356.htm#bookmark1902" class="s23">until it </a><span class="p">gets </span>T<span class="s35">2 </span><span class="p">to carry out its designated task, that is, not until </span>P<span class="s35">2 </span><span class="p">has released </span>T<span class="s35">2</span><span class="p">, whereas </span>P<span class="s35">2 </span><a href="part356.htm#bookmark1902" class="s23">will </a><span class="p">not release </span>T<span class="s44">2</span> <span class="p">until it gets </span>T<span class="s44">1</span><a href="part356.htm#bookmark1902" class="s23">. Therefore, the two processes are in a state of deadlock. Note that the requests made by the two processes are legal because each is requesting for only two tape drives,</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part356.htm#bookmark1902" class="s23">which is the total number of tape drives available in the system. However, the deadlock problem occurs because the total requests of both processes exceed the total number of units for the tape drive and the resource allocation policy is such that it immediately allocates a resource </a>on request, if the resource is free.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: justify;">Necessary Conditions for Deadlock</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">The following conditions are necessary for a deadlock to occur in a system:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Mutual-exclusion condition. </b><a href="part356.htm#bookmark1902" class="s23">If a process is holding a resource, any other p</a>rocess requesting for that resource must wait until the process releases the resource.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. <b>Hold-and-wait condition. </b><a href="part356.htm#bookmark1902" class="s23">Processes can request for new resources without releasi</a>ng the resources, which they are currently holding.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">3. <b>No-preemption condition. </b><a href="part356.htm#bookmark1902" class="s23">If the operating system has allocated a resource to a process, that resource becomes available for allocation to another process only after the p</a>rocess voluntarily releases it.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">4. <b>Circular-wait condition. </b><a href="part356.htm#bookmark1902" class="s23">Two or more processes must form a circular chain in which each process is waiting for a resource that the next member of the chain holds. </a><a href="part356.htm#bookmark1902" class="s3">Figure</a></p><p class="s46" style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: left;">10.14<span class="s10"> </span><span class="p">shows such a circular chain.</span></p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">For a deadlock to occur, all four conditions must hold simultaneously. If any one of them is absent, no deadlock can occur.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 6pt;text-indent: 0pt;text-align: left;">Handling Deadlocks</h4><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">Operating system designers commonly use one of the following three strategies to handle deadlocks:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. <b>Avoidance. </b>Deadlock avoidance methods use some advance knowledge of the resource usage of processes to predict the future state of the system for avoiding allocations that can lead to a deadlock eventually. Usually, deadlock avoidance algorithms follow the following steps:</p><p style="padding-top: 9pt;padding-left: 69pt;text-indent: -15pt;text-align: justify;">a. When a process requests for a resource, even if the resource is available for allocation, the operating system does not allocate it immediately to the process. Rather, the system assumes that the request is granted.</p><p style="padding-top: 3pt;padding-left: 69pt;text-indent: -15pt;text-align: justify;">b. With the assumption made in Step (a) and advance knowledge of the resource usage of processes, the system performs some analysis to decide whether granting the process&#39;s request is safe or unsafe. A system is in a <i>safe state, </i>if there exists some ordering of the processes in which the operating system can grant resources to meet resource requests of the processes to run all of them to completion.</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">Deadlock avoidance algorithms perform resource allocation in a manner to ensure that the system will always remain in a safe state. Since the initial state of a system is always a safe state, whenever a process requests a resource that is currently available, the system checks to find out if the allocation of the resource to the process will change the state of the system from safe to unsafe. If no, the operating system grants the request immediately, otherwise it defers allocation of the resource to the process.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. <b>Prevention. </b>This approach somehow ensures that at least one of the four necessary conditions for deadlock is never satisfied, making deadlocks impossible. The two commonly known deadlock prevention methods are collective requests and ordered requests. They are described here.</p><p style="padding-top: 9pt;padding-left: 69pt;text-indent: -15pt;text-align: justify;">a. <i>Collective requests. </i>This method denies the hold-and-wait condition by ensuring that whenever a process requests a resource, it does not hold any other resources. For example, one way to ensure this is to make a process request all its resources before it begins execution.</p><p style="padding-top: 3pt;padding-left: 69pt;text-indent: -15pt;text-align: justify;"><a name="bookmark1904">b. </a><i>Ordered requests. </i>This method denies the circular-wait condition. It assigns a unique global number to each resource type to impose a total ordering of all resource types. Now, the operating system uses a resource allocation policy in which a process can request a resource at any time, but the process should not request a resource with a number lower than the number of any of the resources that it is already holding. That is, if a process holds a resource type whose number is <i>i</i>, it may request a resource type having the number <i>j </i>only if <i>j &gt; i</i>.</p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">3. <b>Detection and recovery. </b>In this approach, the operating system does not use any</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">deadlock avoidance or prevention mechanism, and allows deadlocks to occur. Instead, it uses a detection algorithm to detect deadlocks. After it detects a deadlock, it resolves it in one of the following two ways:</p><p style="padding-top: 8pt;padding-left: 68pt;text-indent: -15pt;text-align: justify;">a. <i>Asking for operator intervention. </i>The operating system informs the operator that a deadlock has occurred (specifying the list of processes involved in the deadlock), and then the operator deals with it manually.</p><p style="padding-top: 3pt;padding-left: 68pt;text-indent: -15pt;text-align: justify;">b. <i>Termination/Rollback of processes. </i>The operating system terminates or rolls back one or more processes involved in the deadlock to break the deadlock.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part355.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part357.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
