<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Digital Signature</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part555.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part557.htm">Далее &gt;</a></p><p style="padding-bottom: 3pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark554" name="bookmark2478">DIGITAL SIGNATURE</a><a name="bookmark2582">&zwnj;</a></p><p style="padding-left: 6pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="624" height="1" alt="image" src="Image_817.png"/></span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Message integrity, which guarantees that no one tampered with the contents of a message when it was in transfer, is an important security requirement in a distributed system. The concept of digital signature, which uses asymmetric cryptosystems, is the most commonly used method to handle this requirement.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Recall that in an asymmetric cryptosystem, only a user (no one else) knows his/her secret key. Therefore, the sender of a message can use its secret key for signing the message by encrypting it with the key. That is, the sender can uniquely “seal” the message with his/her own signature (secret key). The system can then send the sealed message to anyone with the corresponding public key. A digitally signed message not only assures the receiver of the message that the message content has not been manipulated, but also assures that the message was indeed sent by the claimed sender. Thus, digital signatures are applicable to both user authentication and message integrity.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">A <i>digital signature </i>is a code, or a large number, that is unique to each message and to each message originator. It is obtained by first processing the message with a hash function (called a <i>digest function) </i>to obtain a small digest dependent on each bit of information in the message and then encrypting the digest by using the originator&#39;s secret key. To avoid duplicity problems, a digest function <i>(D) </i>must have the property that <i>D(M) </i>is different from <i>D(M&#39;) </i>for all possible pairs of <i>M </i>and <i>M&#39;. MD5 </i>is a message digest function for use in secure mail and other applications on the Internet.</p><p style="padding-top: 4pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">Let us take an example to illustrate how a message digest function obtains the digest of a</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">message from the message. Let us also assume that a message is a digital string of 0&#39;s and 1&#39;s and is divided into blocks of 64 bits. The function first performs bitwise Exclusive-OR of the first two blocks to obtain a new block of 64 bits. It again performs bitwise Exclusive-OR of the newly obtained block with the third block of the message, again resulting in a new block of 64 bits. It repeats this process one-by-one with all other blocks of the message. The result is a 64-bit digest that depends on each bit of data in the whole message stream. In other words, to alter the message, even by 1 bit, would alter the 64-bit digest. Moreover, it should be essentially impossible to forge a message that would result in the same digest.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">A protocol based on a digital signature for ensuring message integrity works as follows:</p><p class="s16" style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><a name="bookmark2583"><span class="p">1. A sender </span></a>(A) <span class="p">computes digest </span>(D) <span class="p">of a message </span>(M). <span class="p">It then encrypts digest </span>D <span class="p">by using its secret key </span>(S<span class="s35">a</span>) <span class="p">to obtain a ciphertext </span>C<span class="s44">1</span> <span class="p">= </span>E(D, S<span class="s35">a</span>). <span class="p">It then creates a signed message that consists of the sender&#39;s identifier, message </span>M <span class="p">in its plaintext form, and ciphertext </span>C<span class="s44">1</span>. <span class="p">It</span></p><p class="s16" style="padding-top: 2pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;"><span class="p">then sends the signed message, which has the form </span>(ID<span class="s35">a</span>, C<span class="s44">1</span>, M), <span class="p">to a receiver.</span></p><p class="s16" style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;line-height: 109%;text-align: justify;"><span class="p">2. On receiving the signed message, the receiver decrypts </span>C<span class="s44">1</span> <span class="p">by using the public key of the sender to recover digest </span>D<span class="p">. It then calculates a digest for </span>M <span class="p">(by using the same digest function) and compares the calculated digest with the digest recovered by decrypting </span>C<span class="s44">1</span>.</p><p style="padding-top: 1pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">If the two are equal, it considers message <i>M </i>correct; otherwise, it considers it incorrect.</p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Notice that the protocol does not hide a message from unauthorized users. Rather, it allows reading of a message by anyone who receives or intercepts it. However, the protocol detects a forged message successfully.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">An application may require that the first receiver retransmit the signed message to another receiver, which may have to retransmit it subsequently to other receivers. In such a situation, it is important that each of the recipients should be able to verify that the signed message indeed originated from the claimed originator and that any of the intermediate recipients or an intruder did not change its contents. A digitally signed message meets these requirements because it has the originator&#39;s identifier included in it and only a user having the originator&#39;s public key can decrypt the digest of the message.</p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">An actual implementation may use a key distribution server that maintains a database of public keys of all users. If a receiver of a digitally signed message does not already have the public key of the message originator, it can request it from the key distribution server. This avoids the need to send a new user&#39;s public key to all other users in the system. A new user needs to register its public key only with the key distribution server.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part555.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part557.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
