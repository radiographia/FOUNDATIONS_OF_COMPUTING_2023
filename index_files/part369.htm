<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Disk Space Allocation Methods</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part368.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part370.htm">Далее &gt;</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="#bookmark367" name="bookmark1828">Disk Space Allocation Methods</a><a name="bookmark1938">&zwnj;</a></p><p style="padding-top: 5pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Normally, for permanent storage, a system stores files on disks, and a disk stores many files. Disk space allocation methods deal with how to allocate space to multiple files on disk to meet the following two objectives:</p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. The system makes effective utilization of disk space, and</p><p style="padding-top: 4pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">2. The system can quickly access a piece of information from any file.</p><p style="padding-top: 9pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part369.htm#bookmark1939" class="s23">The three methods that operating systems use commonly for disk space allocation are contiguous, linked, and indexed. They are described here. However, before that, it is important to note that operating systems divide the total disk storage space into equal sized </a><a href="part369.htm#bookmark1939" class="s33">blocks </a><a href="part369.htm#bookmark1939" class="s23">(see </a><a href="part369.htm#bookmark1939" class="s3">Figure</a><a href="part369.htm#bookmark1939" class="s24"> </a><a href="part369.htm#bookmark1939" class="s3">10.25</a><a href="part369.htm#bookmark1939" class="s23">). Normally, the size of a block is a multiple of page size in systems that use </a>paging mechanism for memory management. The operating system allocates disk space to files in units of blocks. It is possible to read a block from the disk, to modify the block, and write it back into the same place.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 148pt;text-indent: 0pt;text-align: left;"><span><img width="246" height="167" alt="image" src="Image_633.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1939">Figure 10.25. </a><span class="s21">Storage space of a disk partitioned into equal sized blocks.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-top: 6pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a name="bookmark1940">Contiguous Allocation</a></h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;"><a href="part369.htm#bookmark1941" class="s23">In this method, each file occupies a set of contiguous blocks on a disk. Hence, if a disk has 2K blocks, the operating system will allocate 6 contiguous blocks to a file of size 11K. As </a><a href="part369.htm#bookmark1941" class="s3">Figure</a></p><p style="padding-left: 6pt;text-indent: 0pt;text-align: left;"><a href="part369.htm#bookmark1941" class="s3">10.26</a><a href="part369.htm#bookmark1941" class="s24"> </a><a href="part369.htm#bookmark1941" class="s23">shows, in this method, the operating system stores in the directory the starting </a>block number and total number of blocks for each file as disk addresses of file.</p><p style="padding-left: 111pt;text-indent: 0pt;text-align: left;"><span><img width="345" height="193" alt="image" src="Image_634.jpg"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s20" style="padding-top: 4pt;padding-left: 52pt;text-indent: 0pt;text-align: left;"><a name="bookmark1941">Figure 10.26. </a><span class="s21">Illustrating allocation of disk blocks to files in contiguous allocation method.</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">Contiguous disk space allocation has the following advantages:</p><p style="padding-top: 9pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">1. It is simple to implement.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">2. Its performance is excellent because the operating system can read an entire file from disk in a single operation.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: left;">3. It easily supports both sequential and direct access because all blocks of a file are contiguous.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">This method, however, has the following drawbacks:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. It suffers from external fragmentation problem. <i>External fragmentation </i>is a situation when enough total free disk blocks exist to satisfy the disk space requirement of a file, but the operating system cannot store the file on disk because the available free disk blocks are not contiguous. The amount of unusable disk space due to external fragmentation depends on total disk space and average disk space required by files. However, statistical analysis indicates that as much as one-third of disk space may be unusable due to external fragmentation. To take care of this problem, systems using contiguous disk space allocation method often provide <i>disk compaction </i>facility<i>, </i>which moves files to bring all free blocks together. Disk compaction is a time consuming operation and may take several hours. Hence, the operating system performs disk compaction usually at low-activity hours (such as at night) when the system is otherwise idle.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. Another problem with this method is for the operating system to decide how much space it should allocate to a new file so that it has appropriate number of contiguous blocks for the file. In general, it is difficult to estimate the size of an output file. If the operating system overestimates the size, it will lead to unused disk space due to internal fragmentation. On the other hand, if the operating system underestimates the size, it will have to move the file completely to a new area on the disk when the file size grows beyond the originally estimated size. This often leads to external fragmentation problem and slower file access operations.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Linked Allocation</h4><p class="s46" style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: left;"><a href="part369.htm#bookmark1943" class="s23">As </a>Figure 10.27<span class="s10"> </span><span class="p">shows, in this method, the operating system maintains a linked list of the set of disk blocks that it allocates to a file. It uses the first word of each disk block to store a pointer to</span></p><p class="s46" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;"><a href="part369.htm#bookmark1943" class="s23" name="bookmark1942">the next one, and uses the rest of the words in the block to store file data. Hence, the operating system can allocate disk blocks to a file from anywhere on the disk. As </a><a href="part369.htm#bookmark1943" class="s3">Figure </a>10.27<span class="s10"> </span><span class="p">shows, in this method, the disk address in the directory indicates the number of the first block of each file.</span></p><p style="padding-top: 4pt;padding-left: 6pt;text-indent: 0pt;text-align: justify;">Linked disk space allocation method has the following advantages:</p><p style="padding-top: 9pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">1. There is no external fragmentation in this method. The operating system can use every disk block. Since there is no loss of disk space due to external fragmentation, there is no need to implement disk compaction facility.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;">2. There is no need for the operating system to determine and declare the total anticipated size of a file at the time of its creation. A file can grow freely at any time since the operating system can allocate new disk blocks to the file from anywhere on the disk.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;"><span><img width="480" height="179" alt="image" src="Image_635.jpg"/></span></p><p class="s20" style="padding-top: 9pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1943">Figure 10.27. </a><span class="s21">Illustrating allocation of disk blocks to files in linked allocation method.</span></p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">The method, however, has the following drawbacks:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. The method is suitable for use for sequential-access files only because random access of files in this method is extremely slow. For example, to access some data from the <i>i</i><span class="s31">th </span>block of a file, the operating system has to start at the first block and follow the pointers until it gets to the <i>i</i><span class="s31">th </span>block. This is slow because each access to a pointer requires accessing a new block that requires a disk read operation.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. Another problem is reliability. Since the operating system maintains a linked list of blocks of a file by using pointers, which are scattered all over the disk, if a pointer is lost due to disk corruption, all file data beyond that disk block becomes inaccessible. This leads to garbage blocks (blocks that are neither free nor in use) and requires implementation of a garbage collection algorithm. This algorithm searches for garbage blocks and adds them to the list of free disk blocks.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><h4 style="padding-left: 5pt;text-indent: 0pt;text-align: justify;">Indexed Allocation</h4><p style="padding-top: 5pt;padding-left: 5pt;text-indent: 0pt;text-align: justify;">In this method also, the operating system can allocate disk blocks to a file from anywhere on the disk. However, unlike linked allocation in which the operating system maintains a linked list of the set of blocks it allocates to a file, in this method, it stores the pointers to the set of blocks it allocates to a file in a special block known as <i>index block</i>. Thus, each file has its own index block, which is an array of disk block addresses. The <i>i</i><span class="s31">th </span>entry in the index block points to the <i>i</i><span class="s31">th </span><a href="part369.htm#bookmark1944" class="s23">block of the file. As </a><a href="part369.htm#bookmark1944" class="s3">Figure </a><span class="s46">10.28</span> shows, in this method, the disk address in the directory</p><p style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;">indicates the number of the index block of each file.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 71pt;text-indent: 0pt;text-align: left;"><span><img width="450" height="402" alt="image" src="Image_636.jpg"/></span></p><p class="s20" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;text-align: center;"><a name="bookmark1944">Figure 10.28. </a><span class="s21">Illustrating allocation of disk blocks to files in indexed allocation method.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 5pt;text-indent: 0pt;text-align: left;">Indexed disk space allocation method has the following advantages:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. There is no external fragmentation in this method. The operating system can use every disk block. Since there is no loss of disk space due to external fragmentation, there is no need to implement disk compaction facility.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">2. There is no need for the operating system to determine and declare the total anticipated size of a file at the time of its creation. A file can grow freely at any time since the operating system can allocate new disk blocks to the file from anywhere on the disk.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">3. The method is suitable for use for both random-access and sequential-access files. Once the operating system loads the index block of a file into main memory (which is does when a user opens the file for use), the operating system can directly access the block corresponding to any part of the file by using the information in the index block.</p><p style="padding-top: 9pt;padding-left: 5pt;text-indent: 0pt;text-align: left;">The method, however, has the following drawbacks:</p><p style="padding-top: 9pt;padding-left: 38pt;text-indent: -15pt;text-align: justify;">1. It suffers from wastage of disk space, especially when most files are small. This is because the operating system allocates one index block to each file irrespective of the number of data blocks for a file. Hence, if a file has only one or two data blocks, the operating system uses an entire index block for storing just one or two pointers, leaving the index block area largely unused.</p><p style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: justify;">One way to take care of this problem is to have enough space in the directory so that the</p><p style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: justify;">operating system can store the first few (say <i>n</i>) block addresses in the directory itself. Hence, for small files, all necessary information is right in the directory. The operating system needs to allocate an index block to a file only when the file requires more than <i>n </i>blocks for storing its data.</p><p style="padding-top: 4pt;padding-left: 39pt;text-indent: -15pt;text-align: justify;"><a name="bookmark1945">2. It suffers from the problem of handling large files. This is because if the index block has space that is sufficient to store only </a><i>m </i>disk block addresses, then how can the operating system store files of size larger than <i>m </i>disk blocks? Operating systems often take care of this problem by using the method of multilevel index. In this method, one of the addresses in the index block is the address of a disk block called the <i>second-level index block</i>. This block contains pointers to additional disk blocks of a file of size larger than <i>m </i>disk blocks. An operating system can use third or fourth level index blocks to support very large files, but two levels of indexes are generally sufficient.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part368.htm">&lt; Назад</a><span> | </span><a href="../index.html">Содержимое</a><span> | </span><a href="part370.htm">Далее &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
